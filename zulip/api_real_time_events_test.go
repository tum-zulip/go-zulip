/*
Zulip REST API

Testing RealTimeEventsAPIService

*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech);

package zulip_test

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/tum-zulip/go-zulip/zulip"
)

func Test_RealTimeEventsAPIService(t *testing.T) {
	t.Parallel()

	t.Run("DeleteQueue", runForAllClients(t, func(t *testing.T, apiClient *zulip.Client) {
		ctx := context.Background()

		resp, httpRes, err := apiClient.DeleteQueue(ctx).Execute()

		require.NoError(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	}))

	t.Run("GetEvents", runForAllClients(t, func(t *testing.T, apiClient *zulip.Client) {
		ctx := context.Background()

		resp, httpRes, err := apiClient.GetEvents(ctx).Execute()

		require.NoError(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	}))

	t.Run("RealTimePost", runForAllClients(t, func(t *testing.T, apiClient *zulip.Client) {
		ctx := context.Background()

		httpRes, err := apiClient.RealTimePost(ctx).Execute()

		require.NoError(t, err)
		assert.Equal(t, 200, httpRes.StatusCode)

	}))

	t.Run("RegisterQueue", runForAllClients(t, func(t *testing.T, apiClient *zulip.Client) {
		ctx := context.Background()

		resp, httpRes, err := apiClient.RegisterQueue(ctx).Execute()

		require.NoError(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	}))

	t.Run("QueueReceivesMessageEvent", runForAllClients(t, func(t *testing.T, apiClient *zulip.Client) {
		queue := registerMessageEventQueue(t, apiClient)

		t.Cleanup(func() {
			_, _, cleanupErr := apiClient.DeleteQueue(context.Background()).
				QueueId(queue.id).
				Execute()
			if cleanupErr != nil {
				t.Fatalf("failed to delete queue %s: %v", queue.id, cleanupErr)
			}
		})

		_, updatedLast := fetchQueueEvents(t, context.Background(), apiClient, queue.id, queue.lastEventID, true)
		queue.lastEventID = updatedLast

		userId := getOwnUserId(t, apiClient)
		messageContent := fmt.Sprintf("event queue test %s", uniqueName("message"))

		type sendResult struct {
			id  int64
			err error
		}

		sendCh := make(chan sendResult, 1)
		go func() {
			sendCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()

			resp, httpRes, err := apiClient.SendMessage(sendCtx).
				RecipientType(zulip.RecipientTypeDirect).
				To(zulip.UserAsRecipient(userId)).
				Content(messageContent).
				Execute()
			if err != nil {
				sendCh <- sendResult{err: fmt.Errorf("send message: %w", err)}
				return
			}
			if httpRes == nil {
				sendCh <- sendResult{err: fmt.Errorf("nil http response")}
				return
			}
			if httpRes.StatusCode != 200 {
				sendCh <- sendResult{err: fmt.Errorf("unexpected status %d", httpRes.StatusCode)}
				return
			}
			if resp == nil {
				sendCh <- sendResult{err: fmt.Errorf("nil response")}
				return
			}
			sendCh <- sendResult{id: resp.Id}
		}()

		eventCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		events, newLast := fetchQueueEvents(t, eventCtx, apiClient, queue.id, queue.lastEventID, false)
		queue.lastEventID = newLast

		sendRes := <-sendCh
		require.NoError(t, sendRes.err)

		require.NotEmpty(t, events)

		var found bool
		for _, raw := range events {
			var msg struct {
				Type    string `json:"type"`
				Message struct {
					Id int64 `json:"id"`
				} `json:"message"`
			}
			if err := json.Unmarshal(raw, &msg); err != nil {
				continue
			}
			if msg.Type == "message" && msg.Message.Id == sendRes.id {
				found = true
				break
			}
		}

		require.True(t, found, "expected message event with id %d", sendRes.id)
	}))

	t.Run("RestErrorHandling", runForAllClients(t, func(t *testing.T, apiClient *zulip.Client) {
		ctx := context.Background()

		httpRes, err := apiClient.RestErrorHandling(ctx).Execute()

		require.NoError(t, err)
		assert.Equal(t, 200, httpRes.StatusCode)

	}))
}

type eventQueueState struct {
	id          string
	lastEventID int64
}

func registerMessageEventQueue(t *testing.T, apiClient *zulip.Client) eventQueueState {
	t.Helper()

	rc := apiClient.GetZulipRC()
	require.NotNil(t, rc)
	require.NotEmpty(t, rc.Site)
	require.NotEmpty(t, rc.Email)
	require.NotEmpty(t, rc.APIKey)

	form := url.Values{}
	form.Set("event_types", "[\"message\"]")

	endpoint := strings.TrimRight(rc.Site, "/") + "/api/v1/register"
	req, err := http.NewRequestWithContext(context.Background(), http.MethodPost, endpoint, strings.NewReader(form.Encode()))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.SetBasicAuth(rc.Email, rc.APIKey)

	client := &http.Client{Timeout: 15 * time.Second}
	res, err := client.Do(req)
	require.NoError(t, err)
	defer res.Body.Close()
	require.Equal(t, http.StatusOK, res.StatusCode)

	body, err := io.ReadAll(res.Body)
	require.NoError(t, err)

	var payload struct {
		Result      string `json:"result"`
		QueueID     string `json:"queue_id"`
		LastEventID int64  `json:"last_event_id"`
		Msg         string `json:"msg"`
	}
	require.NoError(t, json.Unmarshal(body, &payload))
	require.Equal(t, "success", payload.Result, "register queue failed: %s", payload.Msg)
	require.NotEmpty(t, payload.QueueID)

	return eventQueueState{id: payload.QueueID, lastEventID: payload.LastEventID}
}

func fetchQueueEvents(t *testing.T, ctx context.Context, apiClient *zulip.Client, queueID string, lastEventID int64, dontBlock bool) ([]json.RawMessage, int64) {
	t.Helper()

	rc := apiClient.GetZulipRC()
	require.NotNil(t, rc)
	require.NotEmpty(t, rc.Site)
	require.NotEmpty(t, rc.Email)
	require.NotEmpty(t, rc.APIKey)

	params := url.Values{}
	params.Set("queue_id", queueID)
	params.Set("last_event_id", fmt.Sprintf("%d", lastEventID))
	if dontBlock {
		params.Set("dont_block", "true")
	}

	endpoint := strings.TrimRight(rc.Site, "/") + "/api/v1/events"
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, endpoint+"?"+params.Encode(), nil)
	require.NoError(t, err)
	req.SetBasicAuth(rc.Email, rc.APIKey)

	client := &http.Client{}
	res, err := client.Do(req)
	require.NoError(t, err)
	defer res.Body.Close()
	require.Equal(t, http.StatusOK, res.StatusCode)

	body, err := io.ReadAll(res.Body)
	require.NoError(t, err)

	var payload struct {
		Result  string            `json:"result"`
		Events  []json.RawMessage `json:"events"`
		Msg     string            `json:"msg"`
		QueueID string            `json:"queue_id"`
	}
	require.NoError(t, json.Unmarshal(body, &payload))
	require.Equal(t, "success", payload.Result, "get events failed: %s", payload.Msg)
	if payload.QueueID != "" {
		require.Equal(t, queueID, payload.QueueID)
	}

	newLast := lastEventID
	for _, raw := range payload.Events {
		var header struct {
			Id int64 `json:"id"`
		}
		if err := json.Unmarshal(raw, &header); err == nil {
			if header.Id > newLast {
				newLast = header.Id
			}
		}
	}

	return payload.Events, newLast
}
