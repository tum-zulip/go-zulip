/*
Zulip REST API

Powerful open source group chat

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/tum-zulip/go-zulip/pkg/models"
)

type ScheduledMessagesAPI interface {

	/*
			CreateScheduledMessage Create a scheduled message

			Create a new [scheduled message](/help/schedule-a-message).

		**Changes**: In Zulip 7.0 (feature level 184), moved support for
		[editing a scheduled message](/api/update-scheduled-message) to a
		separate API endpoint, which removed the `scheduled_message_id`
		parameter from this endpoint.

		New in Zulip 7.0 (feature level 179).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiCreateScheduledMessageRequest
	*/
	CreateScheduledMessage(ctx context.Context) ApiCreateScheduledMessageRequest

	// CreateScheduledMessageExecute executes the request
	//  @return models.CreateScheduledMessage200Response
	CreateScheduledMessageExecute(r ApiCreateScheduledMessageRequest) (*models.CreateScheduledMessage200Response, *http.Response, error)

	/*
			DeleteScheduledMessage Delete a scheduled message

			Delete, and therefore cancel sending, a previously [scheduled
		message](/help/schedule-a-message).

		**Changes**: New in Zulip 7.0 (feature level 173).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param scheduledMessageId The ID of the scheduled message to delete.  This is different from the unique ID that the message would have after being sent.
			@return ApiDeleteScheduledMessageRequest
	*/
	DeleteScheduledMessage(ctx context.Context, scheduledMessageId int32) ApiDeleteScheduledMessageRequest

	// DeleteScheduledMessageExecute executes the request
	//  @return models.JsonSuccess
	DeleteScheduledMessageExecute(r ApiDeleteScheduledMessageRequest) (*models.JsonSuccess, *http.Response, error)

	/*
			GetScheduledMessages Get scheduled messages

			Fetch all [scheduled messages](/help/schedule-a-message) for
		the current user.

		Scheduled messages are messages the user has scheduled to be
		sent in the future via the send later feature.

		**Changes**: New in Zulip 7.0 (feature level 173).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiGetScheduledMessagesRequest
	*/
	GetScheduledMessages(ctx context.Context) ApiGetScheduledMessagesRequest

	// GetScheduledMessagesExecute executes the request
	//  @return models.GetScheduledMessages200Response
	GetScheduledMessagesExecute(r ApiGetScheduledMessagesRequest) (*models.GetScheduledMessages200Response, *http.Response, error)

	/*
			UpdateScheduledMessage Edit a scheduled message

			Edit an existing [scheduled message](/help/schedule-a-message).

		**Changes**: New in Zulip 7.0 (feature level 184).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param scheduledMessageId The ID of the scheduled message to update.  This is different from the unique ID that the message would have after being sent.
			@return ApiUpdateScheduledMessageRequest
	*/
	UpdateScheduledMessage(ctx context.Context, scheduledMessageId int32) ApiUpdateScheduledMessageRequest

	// UpdateScheduledMessageExecute executes the request
	//  @return models.UpdateScheduledMessage200Response
	UpdateScheduledMessageExecute(r ApiUpdateScheduledMessageRequest) (*models.UpdateScheduledMessage200Response, *http.Response, error)
}

type ApiCreateScheduledMessageRequest struct {
	ctx                        context.Context
	ApiService                 ScheduledMessagesAPI
	type_                      *string
	to                         *models.CreateScheduledMessageRequestTo
	content                    *string
	scheduledDeliveryTimestamp *int32
	topic                      *string
	readBySender               *bool
}

// The type of scheduled message to be sent. &#x60;\\\&quot;direct\\\&quot;&#x60; for a direct message and &#x60;\\\&quot;stream\\\&quot;&#x60; or &#x60;\\\&quot;channel\\\&quot;&#x60; for a channel message.  Note that, while &#x60;\\\&quot;private\\\&quot;&#x60; is supported for scheduling direct messages, clients are encouraged to use to the modern convention of &#x60;\\\&quot;direct\\\&quot;&#x60; to indicate this message type, because support for &#x60;\\\&quot;private\\\&quot;&#x60; may eventually be removed.  **Changes**: In Zulip 9.0 (feature level 248), &#x60;\\\&quot;channel\\\&quot;&#x60; was added as an additional value for this parameter to indicate the type of a channel message.
func (r ApiCreateScheduledMessageRequest) Type_(type_ string) ApiCreateScheduledMessageRequest {
	r.type_ = &type_
	return r
}

func (r ApiCreateScheduledMessageRequest) To(to models.CreateScheduledMessageRequestTo) ApiCreateScheduledMessageRequest {
	r.to = &to
	return r
}

// The content of the message.  Clients should use the &#x60;max_message_length&#x60; returned by the [&#x60;POST /register&#x60;](/api/register-queue) endpoint to determine the maximum message size.
func (r ApiCreateScheduledMessageRequest) Content(content string) ApiCreateScheduledMessageRequest {
	r.content = &content
	return r
}

// The UNIX timestamp for when the message will be sent, in UTC seconds.
func (r ApiCreateScheduledMessageRequest) ScheduledDeliveryTimestamp(scheduledDeliveryTimestamp int32) ApiCreateScheduledMessageRequest {
	r.scheduledDeliveryTimestamp = &scheduledDeliveryTimestamp
	return r
}

// The topic of the message. Only required for channel messages (&#x60;\\\&quot;type\\\&quot;: \\\&quot;stream\\\&quot;&#x60; or &#x60;\\\&quot;type\\\&quot;: \\\&quot;channel\\\&quot;&#x60;), ignored otherwise.  Clients should use the &#x60;max_topic_length&#x60; returned by the [&#x60;POST /register&#x60;](/api/register-queue) endpoint to determine the maximum topic length.  Note: When &#x60;\\\&quot;(no topic)\\\&quot;&#x60; or the value of &#x60;realm_empty_topic_display_name&#x60; found in the [POST /register](/api/register-queue) response is used for this parameter, it is interpreted as an empty string.  When [topics are required](/help/require-topics), this parameter can&#39;t be &#x60;\\\&quot;(no topic)\\\&quot;&#x60;, an empty string, or the value of &#x60;realm_empty_topic_display_name&#x60;.  **Changes**: Before Zulip 10.0 (feature level 370), &#x60;\\\&quot;(no topic)\\\&quot;&#x60; was not interpreted as an empty string.  Before Zulip 10.0 (feature level 334), empty string was not a valid topic name for channel messages.
func (r ApiCreateScheduledMessageRequest) Topic(topic string) ApiCreateScheduledMessageRequest {
	r.topic = &topic
	return r
}

// Whether the message should be initially marked read by its sender. If unspecified, the server uses a heuristic based on the client name and the recipient.  **Changes**: New in Zulip 8.0 (feature level 236).
func (r ApiCreateScheduledMessageRequest) ReadBySender(readBySender bool) ApiCreateScheduledMessageRequest {
	r.readBySender = &readBySender
	return r
}

func (r ApiCreateScheduledMessageRequest) Execute() (*models.CreateScheduledMessage200Response, *http.Response, error) {
	return r.ApiService.CreateScheduledMessageExecute(r)
}

/*
CreateScheduledMessage Create a scheduled message

Create a new [scheduled message](/help/schedule-a-message).

**Changes**: In Zulip 7.0 (feature level 184), moved support for
[editing a scheduled message](/api/update-scheduled-message) to a
separate API endpoint, which removed the `scheduled_message_id`
parameter from this endpoint.

New in Zulip 7.0 (feature level 179).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateScheduledMessageRequest
*/
func (c *ZulipClient) CreateScheduledMessage(ctx context.Context) ApiCreateScheduledMessageRequest {
	return ApiCreateScheduledMessageRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.CreateScheduledMessage200Response
func (c *ZulipClient) CreateScheduledMessageExecute(r ApiCreateScheduledMessageRequest) (*models.CreateScheduledMessage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.CreateScheduledMessage200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scheduled_messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}
	if r.scheduledDeliveryTimestamp == nil {
		return localVarReturnValue, nil, reportError("scheduledDeliveryTimestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "to", r.to, "form", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "content", r.content, "", "")
	if r.topic != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "topic", r.topic, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "scheduled_delivery_timestamp", r.scheduledDeliveryTimestamp, "form", "")
	if r.readBySender != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "read_by_sender", r.readBySender, "form", "")
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.CreateScheduledMessage400Response
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteScheduledMessageRequest struct {
	ctx                context.Context
	ApiService         ScheduledMessagesAPI
	scheduledMessageId int32
}

func (r ApiDeleteScheduledMessageRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.DeleteScheduledMessageExecute(r)
}

/*
DeleteScheduledMessage Delete a scheduled message

Delete, and therefore cancel sending, a previously [scheduled
message](/help/schedule-a-message).

**Changes**: New in Zulip 7.0 (feature level 173).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param scheduledMessageId The ID of the scheduled message to delete.  This is different from the unique ID that the message would have after being sent.
	@return ApiDeleteScheduledMessageRequest
*/
func (c *ZulipClient) DeleteScheduledMessage(ctx context.Context, scheduledMessageId int32) ApiDeleteScheduledMessageRequest {
	return ApiDeleteScheduledMessageRequest{
		ApiService:         c,
		ctx:                ctx,
		scheduledMessageId: scheduledMessageId,
	}
}

// Execute executes the request
//
//	@return models.JsonSuccess
func (c *ZulipClient) DeleteScheduledMessageExecute(r ApiDeleteScheduledMessageRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.JsonSuccess
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scheduled_messages/{scheduled_message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"scheduled_message_id"+"}", url.PathEscape(parameterValueToString(r.scheduledMessageId, "scheduledMessageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v models.CodedError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScheduledMessagesRequest struct {
	ctx        context.Context
	ApiService ScheduledMessagesAPI
}

func (r ApiGetScheduledMessagesRequest) Execute() (*models.GetScheduledMessages200Response, *http.Response, error) {
	return r.ApiService.GetScheduledMessagesExecute(r)
}

/*
GetScheduledMessages Get scheduled messages

Fetch all [scheduled messages](/help/schedule-a-message) for
the current user.

Scheduled messages are messages the user has scheduled to be
sent in the future via the send later feature.

**Changes**: New in Zulip 7.0 (feature level 173).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetScheduledMessagesRequest
*/
func (c *ZulipClient) GetScheduledMessages(ctx context.Context) ApiGetScheduledMessagesRequest {
	return ApiGetScheduledMessagesRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.GetScheduledMessages200Response
func (c *ZulipClient) GetScheduledMessagesExecute(r ApiGetScheduledMessagesRequest) (*models.GetScheduledMessages200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.GetScheduledMessages200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scheduled_messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateScheduledMessageRequest struct {
	ctx                        context.Context
	ApiService                 ScheduledMessagesAPI
	scheduledMessageId         int32
	type_                      *string
	to                         *models.UpdateScheduledMessageRequestTo
	content                    *string
	topic                      *string
	scheduledDeliveryTimestamp *int32
}

// The type of scheduled message to be sent. &#x60;\\\&quot;direct\\\&quot;&#x60; for a direct message and &#x60;\\\&quot;stream\\\&quot;&#x60; or &#x60;\\\&quot;channel\\\&quot;&#x60; for a channel message.  When updating the type of the scheduled message, the &#x60;to&#x60; parameter is required. And, if updating the type of the scheduled message to &#x60;\\\&quot;stream\\\&quot;&#x60;/&#x60;\\\&quot;channel\\\&quot;&#x60;, then the &#x60;topic&#x60; parameter is also required.  Note that, while &#x60;\\\&quot;private\\\&quot;&#x60; is supported for scheduling direct messages, clients are encouraged to use to the modern convention of &#x60;\\\&quot;direct\\\&quot;&#x60; to indicate this message type, because support for &#x60;\\\&quot;private\\\&quot;&#x60; may eventually be removed.  **Changes**: In Zulip 9.0 (feature level 248), &#x60;\\\&quot;channel\\\&quot;&#x60; was added as an additional value for this parameter to indicate the type of a channel message.
func (r ApiUpdateScheduledMessageRequest) Type_(type_ string) ApiUpdateScheduledMessageRequest {
	r.type_ = &type_
	return r
}

func (r ApiUpdateScheduledMessageRequest) To(to models.UpdateScheduledMessageRequestTo) ApiUpdateScheduledMessageRequest {
	r.to = &to
	return r
}

// The updated content of the scheduled message.  Clients should use the &#x60;max_message_length&#x60; returned by the [&#x60;POST /register&#x60;](/api/register-queue) endpoint to determine the maximum message size.
func (r ApiUpdateScheduledMessageRequest) Content(content string) ApiUpdateScheduledMessageRequest {
	r.content = &content
	return r
}

// The updated topic of the scheduled message.  Required when updating the &#x60;type&#x60; of the scheduled message to &#x60;\\\&quot;stream\\\&quot;&#x60; or &#x60;\\\&quot;channel\\\&quot;&#x60;. Ignored when the existing or updated &#x60;type&#x60; of the scheduled message is &#x60;\\\&quot;direct\\\&quot;&#x60; (or &#x60;\\\&quot;private\\\&quot;&#x60;).  Clients should use the &#x60;max_topic_length&#x60; returned by the [&#x60;POST /register&#x60;](/api/register-queue) endpoint to determine the maximum topic length.  Note: When &#x60;\\\&quot;(no topic)\\\&quot;&#x60; or the value of &#x60;realm_empty_topic_display_name&#x60; found in the [POST /register](/api/register-queue) response is used for this parameter, it is interpreted as an empty string.  When [topics are required](/help/require-topics), this parameter can&#39;t be &#x60;\\\&quot;(no topic)\\\&quot;&#x60;, an empty string, or the value of &#x60;realm_empty_topic_display_name&#x60;.  **Changes**: Before Zulip 10.0 (feature level 370), &#x60;\\\&quot;(no topic)\\\&quot;&#x60; was not interpreted as an empty string.  Before Zulip 10.0 (feature level 334), empty string was not a valid topic name for channel messages.
func (r ApiUpdateScheduledMessageRequest) Topic(topic string) ApiUpdateScheduledMessageRequest {
	r.topic = &topic
	return r
}

// The UNIX timestamp for when the message will be sent, in UTC seconds.  Required when updating a scheduled message that the server has already tried and failed to send. This state is indicated with &#x60;\\\&quot;failed\\\&quot;: true&#x60; in &#x60;scheduled_messages&#x60; objects; see response description at [&#x60;GET /scheduled_messages&#x60;](/api/get-scheduled-messages#response).
func (r ApiUpdateScheduledMessageRequest) ScheduledDeliveryTimestamp(scheduledDeliveryTimestamp int32) ApiUpdateScheduledMessageRequest {
	r.scheduledDeliveryTimestamp = &scheduledDeliveryTimestamp
	return r
}

func (r ApiUpdateScheduledMessageRequest) Execute() (*models.UpdateScheduledMessage200Response, *http.Response, error) {
	return r.ApiService.UpdateScheduledMessageExecute(r)
}

/*
UpdateScheduledMessage Edit a scheduled message

Edit an existing [scheduled message](/help/schedule-a-message).

**Changes**: New in Zulip 7.0 (feature level 184).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param scheduledMessageId The ID of the scheduled message to update.  This is different from the unique ID that the message would have after being sent.
	@return ApiUpdateScheduledMessageRequest
*/
func (c *ZulipClient) UpdateScheduledMessage(ctx context.Context, scheduledMessageId int32) ApiUpdateScheduledMessageRequest {
	return ApiUpdateScheduledMessageRequest{
		ApiService:         c,
		ctx:                ctx,
		scheduledMessageId: scheduledMessageId,
	}
}

// Execute executes the request
//
//	@return models.UpdateScheduledMessage200Response
func (c *ZulipClient) UpdateScheduledMessageExecute(r ApiUpdateScheduledMessageRequest) (*models.UpdateScheduledMessage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.UpdateScheduledMessage200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scheduled_messages/{scheduled_message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"scheduled_message_id"+"}", url.PathEscape(parameterValueToString(r.scheduledMessageId, "scheduledMessageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	}
	if r.to != nil {
		paramJson, err := parameterToJson(*r.to)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("to", paramJson)
	}
	if r.content != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "content", r.content, "", "")
	}
	if r.topic != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "topic", r.topic, "", "")
	}
	if r.scheduledDeliveryTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "scheduled_delivery_timestamp", r.scheduledDeliveryTimestamp, "form", "")
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.CreateScheduledMessage400Response
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v models.CodedError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
