/*
Zulip REST API

Powerful open source group chat 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"

	"github.com/tum-zulip/go-zulip/pkg/models"
	"strings"
	"os"
)


type ServerAndOrganizationsAPI interface {

	/*
	AddCodePlayground Add a code playground

	Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.

**Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was
fixed in Zulip 4.0 (feature level 57).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddCodePlaygroundRequest
	*/
	AddCodePlayground(ctx context.Context) ApiAddCodePlaygroundRequest

	// AddCodePlaygroundExecute executes the request
	//  @return AddCodePlayground200Response
	AddCodePlaygroundExecute(r ApiAddCodePlaygroundRequest) (*models.AddCodePlayground200Response, *http.Response, error)

	/*
	AddLinkifier Add a linkifier

	Configure [linkifiers](/help/add-a-custom-linkifier),
regular expression patterns that are automatically linkified when they
appear in messages and topics.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddLinkifierRequest
	*/
	AddLinkifier(ctx context.Context) ApiAddLinkifierRequest

	// AddLinkifierExecute executes the request
	//  @return AddLinkifier200Response
	AddLinkifierExecute(r ApiAddLinkifierRequest) (*models.AddLinkifier200Response, *http.Response, error)

	/*
	CreateCustomProfileField Create a custom profile field

	[Create a custom profile field](/help/custom-profile-fields#add-a-custom-profile-field) in the user's organization.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateCustomProfileFieldRequest
	*/
	CreateCustomProfileField(ctx context.Context) ApiCreateCustomProfileFieldRequest

	// CreateCustomProfileFieldExecute executes the request
	//  @return CreateCustomProfileField200Response
	CreateCustomProfileFieldExecute(r ApiCreateCustomProfileFieldRequest) (*models.CreateCustomProfileField200Response, *http.Response, error)

	/*
	DeactivateCustomEmoji Deactivate custom emoji

	[Deactivate a custom emoji](/help/custom-emoji#deactivate-custom-emoji) from
the user's organization.

Users can only deactivate custom emoji that they added themselves except for
organization administrators, who can deactivate any custom emoji.

Note that deactivated emoji will still be visible in old messages, reactions,
user statuses and channel descriptions.

**Changes**: Before Zulip 8.0 (feature level 190), this endpoint returned an
HTTP status code of 400 when the emoji did not exist, instead of 404.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param emojiName The name of the custom emoji to deactivate. 
	@return ApiDeactivateCustomEmojiRequest
	*/
	DeactivateCustomEmoji(ctx context.Context, emojiName string) ApiDeactivateCustomEmojiRequest

	// DeactivateCustomEmojiExecute executes the request
	//  @return JsonSuccess
	DeactivateCustomEmojiExecute(r ApiDeactivateCustomEmojiRequest) (*models.JsonSuccess, *http.Response, error)

	/*
	ExportRealm Create a data export

	Create a public or a standard [data export][export-data] of the organization.

!!! warn ""

    **Note**: If you're the administrator of a self-hosted installation,
    you may be looking for the documentation on [server data export and
    import][data-export] or [server backups][backups].

**Changes**: Prior to Zulip 10.0 (feature level 304), only
public data exports could be created using this endpoint.

New in Zulip 2.1.

[export-data]: /help/export-your-organization#export-for-migrating-to-zulip-cloud-or-a-self-hosted-server
[data-export]: https://zulip.readthedocs.io/en/stable/production/export-and-import.html#data-export
[backups]: https://zulip.readthedocs.io/en/stable/production/export-and-import.html#backups


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiExportRealmRequest
	*/
	ExportRealm(ctx context.Context) ApiExportRealmRequest

	// ExportRealmExecute executes the request
	//  @return ExportRealm200Response
	ExportRealmExecute(r ApiExportRealmRequest) (*models.ExportRealm200Response, *http.Response, error)

	/*
	GetCustomEmoji Get all custom emoji

	Get all the custom emoji in the user's organization.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetCustomEmojiRequest
	*/
	GetCustomEmoji(ctx context.Context) ApiGetCustomEmojiRequest

	// GetCustomEmojiExecute executes the request
	//  @return GetCustomEmoji200Response
	GetCustomEmojiExecute(r ApiGetCustomEmojiRequest) (*models.GetCustomEmoji200Response, *http.Response, error)

	/*
	GetCustomProfileFields Get all custom profile fields

	Get all the [custom profile fields](/help/custom-profile-fields)
configured for the user's organization.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetCustomProfileFieldsRequest
	*/
	GetCustomProfileFields(ctx context.Context) ApiGetCustomProfileFieldsRequest

	// GetCustomProfileFieldsExecute executes the request
	//  @return GetCustomProfileFields200Response
	GetCustomProfileFieldsExecute(r ApiGetCustomProfileFieldsRequest) (*models.GetCustomProfileFields200Response, *http.Response, error)

	/*
	GetLinkifiers Get linkifiers

	List all of an organization's configured
[linkifiers](/help/add-a-custom-linkifier), regular
expression patterns that are automatically linkified when they appear
in messages and topics.

**Changes**: New in Zulip 4.0 (feature level 54). On older versions,
a similar `GET /realm/filters` endpoint was available with each entry in
a `[pattern, url_format, id]` tuple format.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLinkifiersRequest
	*/
	GetLinkifiers(ctx context.Context) ApiGetLinkifiersRequest

	// GetLinkifiersExecute executes the request
	//  @return GetLinkifiers200Response
	GetLinkifiersExecute(r ApiGetLinkifiersRequest) (*models.GetLinkifiers200Response, *http.Response, error)

	/*
	GetPresence Get presence of all users

	Get the presence information of all the users in an organization.

If the `CAN_ACCESS_ALL_USERS_GROUP_LIMITS_PRESENCE` server-level
setting is set to `true`, presence information of only accessible
users are returned.

Complete Zulip apps are recommended to fetch presence
information when they post their own state using the [`POST
/presence`](/api/update-presence) API endpoint.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPresenceRequest
	*/
	GetPresence(ctx context.Context) ApiGetPresenceRequest

	// GetPresenceExecute executes the request
	//  @return GetPresence200Response
	GetPresenceExecute(r ApiGetPresenceRequest) (*models.GetPresence200Response, *http.Response, error)

	/*
	GetRealmExportConsents Get data export consent state

	Fetches which users have [consented](/help/export-your-organization#configure-whether-administrators-can-export-your-private-data)
for their private data to be exported by organization administrators.

**Changes**: New in Zulip 10.0 (feature level 295).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRealmExportConsentsRequest
	*/
	GetRealmExportConsents(ctx context.Context) ApiGetRealmExportConsentsRequest

	// GetRealmExportConsentsExecute executes the request
	//  @return GetRealmExportConsents200Response
	GetRealmExportConsentsExecute(r ApiGetRealmExportConsentsRequest) (*models.GetRealmExportConsents200Response, *http.Response, error)

	/*
	GetRealmExports Get all data exports

	Fetch all the public and standard [data exports][export-data]
of the organization.

**Changes**: Prior to Zulip 10.0 (feature level 304), only
public data exports could be fetched using this endpoint.

New in Zulip 2.1.

[export-data]: /help/export-your-organization#export-for-migrating-to-zulip-cloud-or-a-self-hosted-server


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRealmExportsRequest
	*/
	GetRealmExports(ctx context.Context) ApiGetRealmExportsRequest

	// GetRealmExportsExecute executes the request
	//  @return GetRealmExports200Response
	GetRealmExportsExecute(r ApiGetRealmExportsRequest) (*models.GetRealmExports200Response, *http.Response, error)

	/*
	GetServerSettings Get server settings

	Fetch global settings for a Zulip server.

**Note:** this endpoint does not require any authentication at all, and you can use it to check:

- If this is a Zulip server, and if so, what version of Zulip it's running.
- What a Zulip client (e.g. a mobile app or
  [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to
  know in order to display a login prompt for the server (e.g. what
  authentication methods are available).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetServerSettingsRequest
	*/
	GetServerSettings(ctx context.Context) ApiGetServerSettingsRequest

	// GetServerSettingsExecute executes the request
	//  @return GetServerSettings200Response
	GetServerSettingsExecute(r ApiGetServerSettingsRequest) (*models.GetServerSettings200Response, *http.Response, error)

	/*
	RemoveCodePlayground Remove a code playground

	Remove a [code playground](/help/code-blocks#code-playgrounds) previously
configured for an organization.

**Changes**: New in Zulip 4.0 (feature level 49).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param playgroundId The ID of the playground that you want to remove. 
	@return ApiRemoveCodePlaygroundRequest
	*/
	RemoveCodePlayground(ctx context.Context, playgroundId int32) ApiRemoveCodePlaygroundRequest

	// RemoveCodePlaygroundExecute executes the request
	//  @return JsonSuccess
	RemoveCodePlaygroundExecute(r ApiRemoveCodePlaygroundRequest) (*models.JsonSuccess, *http.Response, error)

	/*
	RemoveLinkifier Remove a linkifier

	Remove [linkifiers](/help/add-a-custom-linkifier), regular
expression patterns that are automatically linkified when they appear
in messages and topics.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param filterId The ID of the linkifier that you want to remove. 
	@return ApiRemoveLinkifierRequest
	*/
	RemoveLinkifier(ctx context.Context, filterId int32) ApiRemoveLinkifierRequest

	// RemoveLinkifierExecute executes the request
	//  @return JsonSuccess
	RemoveLinkifierExecute(r ApiRemoveLinkifierRequest) (*models.JsonSuccess, *http.Response, error)

	/*
	ReorderCustomProfileFields Reorder custom profile fields

	Reorder the custom profile fields in the user's organization.

Custom profile fields are displayed in Zulip UI widgets in order; this
endpoint allows administrative settings UI to change the field ordering.

This endpoint is used to implement the dragging feature described in the
[custom profile fields documentation](/help/custom-profile-fields).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReorderCustomProfileFieldsRequest
	*/
	ReorderCustomProfileFields(ctx context.Context) ApiReorderCustomProfileFieldsRequest

	// ReorderCustomProfileFieldsExecute executes the request
	//  @return JsonSuccess
	ReorderCustomProfileFieldsExecute(r ApiReorderCustomProfileFieldsRequest) (*models.JsonSuccess, *http.Response, error)

	/*
	ReorderLinkifiers Reorder linkifiers

	Change the order that the regular expression patterns in the organization's
[linkifiers](/help/add-a-custom-linkifier) are matched in messages and topics.
Useful when defining linkifiers with overlapping patterns.

**Changes**: New in Zulip 8.0 (feature level 202). Before this feature level,
linkifiers were always processed in order by ID, which meant users would
need to delete and recreate them to reorder the list of linkifiers.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReorderLinkifiersRequest
	*/
	ReorderLinkifiers(ctx context.Context) ApiReorderLinkifiersRequest

	// ReorderLinkifiersExecute executes the request
	//  @return JsonSuccess
	ReorderLinkifiersExecute(r ApiReorderLinkifiersRequest) (*models.JsonSuccess, *http.Response, error)

	/*
	TestWelcomeBotCustomMessage Test welcome bot custom message

	Sends a test Welcome Bot custom message to the acting administrator.
This allows administrators to preview how the custom welcome message will
appear when received by new users upon joining the organization.

**Changes**: New in Zulip 11.0 (feature level 416).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestWelcomeBotCustomMessageRequest
	*/
	TestWelcomeBotCustomMessage(ctx context.Context) ApiTestWelcomeBotCustomMessageRequest

	// TestWelcomeBotCustomMessageExecute executes the request
	//  @return TestWelcomeBotCustomMessage200Response
	TestWelcomeBotCustomMessageExecute(r ApiTestWelcomeBotCustomMessageRequest) (*models.TestWelcomeBotCustomMessage200Response, *http.Response, error)

	/*
	UpdateLinkifier Update a linkifier

	Update a [linkifier](/help/add-a-custom-linkifier), regular
expression patterns that are automatically linkified when they appear
in messages and topics.

**Changes**: New in Zulip 4.0 (feature level 57).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param filterId The ID of the linkifier that you want to update. 
	@return ApiUpdateLinkifierRequest
	*/
	UpdateLinkifier(ctx context.Context, filterId int32) ApiUpdateLinkifierRequest

	// UpdateLinkifierExecute executes the request
	//  @return JsonSuccess
	UpdateLinkifierExecute(r ApiUpdateLinkifierRequest) (*models.JsonSuccess, *http.Response, error)

	/*
	UpdateRealmUserSettingsDefaults Update realm-level defaults of user settings

	Change the [default values of settings][new-user-defaults] for new users
joining the organization. Essentially all
[personal preference settings](/api/update-settings) are supported.

This feature can be invaluable for customizing Zulip's default
settings for notifications or UI to be appropriate for how the
organization is using Zulip. (Note that this only supports
personal preference settings, like when to send push
notifications or what emoji set to use, not profile or
identity settings that naturally should be different for each user).

Note that this endpoint cannot, at present, be used to modify
settings for existing users in any way.

**Changes**: Removed `dense_mode` setting in Zulip 10.0 (feature level 364)
as we now have `web_font_size_px` and `web_line_height_percent`
settings for more control.

New in Zulip 5.0 (feature level 96). If any parameters sent in the
request are not supported by this endpoint, an
[`ignored_parameters_unsupported`][ignored-parameters] array will
be returned in the JSON success response.

[new-user-defaults]: /help/configure-default-new-user-settings
[ignored-parameters]: /api/rest-error-handling#ignored-parameters


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateRealmUserSettingsDefaultsRequest
	*/
	UpdateRealmUserSettingsDefaults(ctx context.Context) ApiUpdateRealmUserSettingsDefaultsRequest

	// UpdateRealmUserSettingsDefaultsExecute executes the request
	//  @return IgnoredParametersSuccess
	UpdateRealmUserSettingsDefaultsExecute(r ApiUpdateRealmUserSettingsDefaultsRequest) (*models.IgnoredParametersSuccess, *http.Response, error)

	/*
	UploadCustomEmoji Upload custom emoji

	This endpoint is used to upload a custom emoji for use in the user's
organization. Access to this endpoint depends on the
[organization's configuration](https://zulip.com/help/custom-emoji#change-who-can-add-custom-emoji).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param emojiName The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (\\_) are treated the same as spaces (consistent with how the Zulip UI handles emoji). 
	@return ApiUploadCustomEmojiRequest
	*/
	UploadCustomEmoji(ctx context.Context, emojiName string) ApiUploadCustomEmojiRequest

	// UploadCustomEmojiExecute executes the request
	//  @return JsonSuccess
	UploadCustomEmojiExecute(r ApiUploadCustomEmojiRequest) (*models.JsonSuccess, *http.Response, error)
}

type ApiAddCodePlaygroundRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	name *string
	pygmentsLanguage *string
	urlTemplate *string
}

// The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language. 
func (r ApiAddCodePlaygroundRequest) Name(name string) ApiAddCodePlaygroundRequest {
	r.name = &name
	return r
}

// The name of the Pygments language lexer for that programming language. 
func (r ApiAddCodePlaygroundRequest) PygmentsLanguage(pygmentsLanguage string) ApiAddCodePlaygroundRequest {
	r.pygmentsLanguage = &pygmentsLanguage
	return r
}

// The [RFC 6570](https://www.rfc-editor.org/rfc/rfc6570.html) compliant URL template for the playground. The template should contain exactly one variable named &#x60;code&#x60;, which determines how the extracted code should be substituted in the playground URL.  **Changes**: New in Zulip 8.0 (feature level 196). This replaced the &#x60;url_prefix&#x60; parameter, which was used to construct URLs by just concatenating &#x60;url_prefix&#x60; and &#x60;code&#x60;. 
func (r ApiAddCodePlaygroundRequest) UrlTemplate(urlTemplate string) ApiAddCodePlaygroundRequest {
	r.urlTemplate = &urlTemplate
	return r
}

func (r ApiAddCodePlaygroundRequest) Execute() (*models.AddCodePlayground200Response, *http.Response, error) {
	return r.ApiService.AddCodePlaygroundExecute(r)
}

/*
AddCodePlayground Add a code playground

Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.

**Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was
fixed in Zulip 4.0 (feature level 57).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddCodePlaygroundRequest
*/
func (a *ZulipClient) AddCodePlayground(ctx context.Context) ApiAddCodePlaygroundRequest {
	return ApiAddCodePlaygroundRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AddCodePlayground200Response
func (a *ZulipClient) AddCodePlaygroundExecute(r ApiAddCodePlaygroundRequest) (*models.AddCodePlayground200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.AddCodePlayground200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/playgrounds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.pygmentsLanguage == nil {
		return localVarReturnValue, nil, reportError("pygmentsLanguage is required and must be specified")
	}
	if r.urlTemplate == nil {
		return localVarReturnValue, nil, reportError("urlTemplate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pygments_language", r.pygmentsLanguage, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "url_template", r.urlTemplate, "", "")
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddLinkifierRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	pattern *string
	urlTemplate *string
}

// The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
func (r ApiAddLinkifierRequest) Pattern(pattern string) ApiAddLinkifierRequest {
	r.pattern = &pattern
	return r
}

// The [RFC 6570](https://www.rfc-editor.org/rfc/rfc6570.html) compliant URL template used for the link. If you used named groups in &#x60;pattern&#x60;, you can insert their content here with &#x60;{name_of_group}&#x60;.  **Changes**: New in Zulip 7.0 (feature level 176). This replaced the &#x60;url_format_string&#x60; parameter, which was a format string in which named groups&#39; content could be inserted with &#x60;%(name_of_group)s&#x60;. 
func (r ApiAddLinkifierRequest) UrlTemplate(urlTemplate string) ApiAddLinkifierRequest {
	r.urlTemplate = &urlTemplate
	return r
}

func (r ApiAddLinkifierRequest) Execute() (*models.AddLinkifier200Response, *http.Response, error) {
	return r.ApiService.AddLinkifierExecute(r)
}

/*
AddLinkifier Add a linkifier

Configure [linkifiers](/help/add-a-custom-linkifier),
regular expression patterns that are automatically linkified when they
appear in messages and topics.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddLinkifierRequest
*/
func (a *ZulipClient) AddLinkifier(ctx context.Context) ApiAddLinkifierRequest {
	return ApiAddLinkifierRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AddLinkifier200Response
func (a *ZulipClient) AddLinkifierExecute(r ApiAddLinkifierRequest) (*models.AddLinkifier200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.AddLinkifier200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/filters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pattern == nil {
		return localVarReturnValue, nil, reportError("pattern is required and must be specified")
	}
	if r.urlTemplate == nil {
		return localVarReturnValue, nil, reportError("urlTemplate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pattern", r.pattern, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "url_template", r.urlTemplate, "", "")
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCustomProfileFieldRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	fieldType *int32
	name *string
	hint *string
	fieldData *map[string]interface{}
	displayInProfileSummary *bool
	required *bool
	editableByUser *bool
}

// The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/custom-profile-fields) for more details on what each type means.  - **1**: Short text - **2**: Long text - **3**: List of options - **4**: Date picker - **5**: Link - **6**: Person picker - **7**: External account - **8**: Pronouns  **Changes**: Field type &#x60;8&#x60; added in Zulip 6.0 (feature level 151). 
func (r ApiCreateCustomProfileFieldRequest) FieldType(fieldType int32) ApiCreateCustomProfileFieldRequest {
	r.fieldType = &fieldType
	return r
}

// The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user&#39;s profile. 
func (r ApiCreateCustomProfileFieldRequest) Name(name string) ApiCreateCustomProfileFieldRequest {
	r.name = &name
	return r
}

// The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
func (r ApiCreateCustomProfileFieldRequest) Hint(hint string) ApiCreateCustomProfileFieldRequest {
	r.hint = &hint
	return r
}

// Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the &#x60;field_data&#x60; attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
func (r ApiCreateCustomProfileFieldRequest) FieldData(fieldData map[string]interface{}) ApiCreateCustomProfileFieldRequest {
	r.fieldData = &fieldData
	return r
}

// Whether clients should display this profile field in a summary section of a user&#39;s profile (or in a more easily accessible \\\&quot;small profile\\\&quot;).  At most 2 profile fields may have this property be true in a given organization. The \\\&quot;Long text\\\&quot; [profile field types][profile-field-types] profile field types cannot be selected to be displayed in profile summaries.  The \\\&quot;Person picker\\\&quot; profile field is also not supported, but that is likely to be temporary.  [profile-field-types]: /help/custom-profile-fields#profile-field-types  **Changes**: New in Zulip 6.0 (feature level 146). 
func (r ApiCreateCustomProfileFieldRequest) DisplayInProfileSummary(displayInProfileSummary bool) ApiCreateCustomProfileFieldRequest {
	r.displayInProfileSummary = &displayInProfileSummary
	return r
}

// Whether an organization administrator has configured this profile field as required.  Because the required property is mutable, clients cannot assume that a required custom profile field has a value. The Zulip web application displays a prominent banner to any user who has not set a value for a required field.  **Changes**: New in Zulip 9.0 (feature level 244). 
func (r ApiCreateCustomProfileFieldRequest) Required(required bool) ApiCreateCustomProfileFieldRequest {
	r.required = &required
	return r
}

// Whether regular users can edit this profile field on their own account.  Note that organization administrators can edit custom profile fields for any user regardless of this setting.  **Changes**: New in Zulip 10.0 (feature level 296). 
func (r ApiCreateCustomProfileFieldRequest) EditableByUser(editableByUser bool) ApiCreateCustomProfileFieldRequest {
	r.editableByUser = &editableByUser
	return r
}

func (r ApiCreateCustomProfileFieldRequest) Execute() (*models.CreateCustomProfileField200Response, *http.Response, error) {
	return r.ApiService.CreateCustomProfileFieldExecute(r)
}

/*
CreateCustomProfileField Create a custom profile field

[Create a custom profile field](/help/custom-profile-fields#add-a-custom-profile-field) in the user's organization.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCustomProfileFieldRequest
*/
func (a *ZulipClient) CreateCustomProfileField(ctx context.Context) ApiCreateCustomProfileFieldRequest {
	return ApiCreateCustomProfileFieldRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCustomProfileField200Response
func (a *ZulipClient) CreateCustomProfileFieldExecute(r ApiCreateCustomProfileFieldRequest) (*models.CreateCustomProfileField200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.CreateCustomProfileField200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/profile_fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fieldType == nil {
		return localVarReturnValue, nil, reportError("fieldType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.hint != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "hint", r.hint, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "field_type", r.fieldType, "form", "")
	if r.fieldData != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "field_data", r.fieldData, "form", "")
	}
	if r.displayInProfileSummary != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "display_in_profile_summary", r.displayInProfileSummary, "form", "")
	}
	if r.required != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "required", r.required, "form", "")
	}
	if r.editableByUser != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "editable_by_user", r.editableByUser, "form", "")
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeactivateCustomEmojiRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	emojiName string
}

func (r ApiDeactivateCustomEmojiRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.DeactivateCustomEmojiExecute(r)
}

/*
DeactivateCustomEmoji Deactivate custom emoji

[Deactivate a custom emoji](/help/custom-emoji#deactivate-custom-emoji) from
the user's organization.

Users can only deactivate custom emoji that they added themselves except for
organization administrators, who can deactivate any custom emoji.

Note that deactivated emoji will still be visible in old messages, reactions,
user statuses and channel descriptions.

**Changes**: Before Zulip 8.0 (feature level 190), this endpoint returned an
HTTP status code of 400 when the emoji did not exist, instead of 404.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param emojiName The name of the custom emoji to deactivate. 
 @return ApiDeactivateCustomEmojiRequest
*/
func (a *ZulipClient) DeactivateCustomEmoji(ctx context.Context, emojiName string) ApiDeactivateCustomEmojiRequest {
	return ApiDeactivateCustomEmojiRequest{
		ApiService: a,
		ctx: ctx,
		emojiName: emojiName,
	}
}

// Execute executes the request
//  @return JsonSuccess
func (a *ZulipClient) DeactivateCustomEmojiExecute(r ApiDeactivateCustomEmojiRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.JsonSuccess
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/emoji/{emoji_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"emoji_name"+"}", url.PathEscape(parameterValueToString(r.emojiName, "emojiName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v models.CodedError
			err = a.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportRealmRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	exportType *int32
}

// Whether to create a public or a standard data export.  - 1 &#x3D; Public data export. - 2 &#x3D; Standard data export.  If not specified, defaults to 1.  **Changes**: New in Zulip 10.0 (feature level 304). Previously, all export requests were public data exports. 
func (r ApiExportRealmRequest) ExportType(exportType int32) ApiExportRealmRequest {
	r.exportType = &exportType
	return r
}

func (r ApiExportRealmRequest) Execute() (*models.ExportRealm200Response, *http.Response, error) {
	return r.ApiService.ExportRealmExecute(r)
}

/*
ExportRealm Create a data export

Create a public or a standard [data export][export-data] of the organization.

!!! warn ""

    **Note**: If you're the administrator of a self-hosted installation,
    you may be looking for the documentation on [server data export and
    import][data-export] or [server backups][backups].

**Changes**: Prior to Zulip 10.0 (feature level 304), only
public data exports could be created using this endpoint.

New in Zulip 2.1.

[export-data]: /help/export-your-organization#export-for-migrating-to-zulip-cloud-or-a-self-hosted-server
[data-export]: https://zulip.readthedocs.io/en/stable/production/export-and-import.html#data-export
[backups]: https://zulip.readthedocs.io/en/stable/production/export-and-import.html#backups


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExportRealmRequest
*/
func (a *ZulipClient) ExportRealm(ctx context.Context) ApiExportRealmRequest {
	return ApiExportRealmRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportRealm200Response
func (a *ZulipClient) ExportRealmExecute(r ApiExportRealmRequest) (*models.ExportRealm200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.ExportRealm200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/export/realm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.exportType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "export_type", r.exportType, "", "")
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.CodedError
			err = a.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomEmojiRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
}

func (r ApiGetCustomEmojiRequest) Execute() (*models.GetCustomEmoji200Response, *http.Response, error) {
	return r.ApiService.GetCustomEmojiExecute(r)
}

/*
GetCustomEmoji Get all custom emoji

Get all the custom emoji in the user's organization.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCustomEmojiRequest
*/
func (a *ZulipClient) GetCustomEmoji(ctx context.Context) ApiGetCustomEmojiRequest {
	return ApiGetCustomEmojiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCustomEmoji200Response
func (a *ZulipClient) GetCustomEmojiExecute(r ApiGetCustomEmojiRequest) (*models.GetCustomEmoji200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.GetCustomEmoji200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/emoji"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomProfileFieldsRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
}

func (r ApiGetCustomProfileFieldsRequest) Execute() (*models.GetCustomProfileFields200Response, *http.Response, error) {
	return r.ApiService.GetCustomProfileFieldsExecute(r)
}

/*
GetCustomProfileFields Get all custom profile fields

Get all the [custom profile fields](/help/custom-profile-fields)
configured for the user's organization.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCustomProfileFieldsRequest
*/
func (a *ZulipClient) GetCustomProfileFields(ctx context.Context) ApiGetCustomProfileFieldsRequest {
	return ApiGetCustomProfileFieldsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCustomProfileFields200Response
func (a *ZulipClient) GetCustomProfileFieldsExecute(r ApiGetCustomProfileFieldsRequest) (*models.GetCustomProfileFields200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.GetCustomProfileFields200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/profile_fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLinkifiersRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
}

func (r ApiGetLinkifiersRequest) Execute() (*models.GetLinkifiers200Response, *http.Response, error) {
	return r.ApiService.GetLinkifiersExecute(r)
}

/*
GetLinkifiers Get linkifiers

List all of an organization's configured
[linkifiers](/help/add-a-custom-linkifier), regular
expression patterns that are automatically linkified when they appear
in messages and topics.

**Changes**: New in Zulip 4.0 (feature level 54). On older versions,
a similar `GET /realm/filters` endpoint was available with each entry in
a `[pattern, url_format, id]` tuple format.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLinkifiersRequest
*/
func (a *ZulipClient) GetLinkifiers(ctx context.Context) ApiGetLinkifiersRequest {
	return ApiGetLinkifiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetLinkifiers200Response
func (a *ZulipClient) GetLinkifiersExecute(r ApiGetLinkifiersRequest) (*models.GetLinkifiers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.GetLinkifiers200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/linkifiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPresenceRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
}

func (r ApiGetPresenceRequest) Execute() (*models.GetPresence200Response, *http.Response, error) {
	return r.ApiService.GetPresenceExecute(r)
}

/*
GetPresence Get presence of all users

Get the presence information of all the users in an organization.

If the `CAN_ACCESS_ALL_USERS_GROUP_LIMITS_PRESENCE` server-level
setting is set to `true`, presence information of only accessible
users are returned.

Complete Zulip apps are recommended to fetch presence
information when they post their own state using the [`POST
/presence`](/api/update-presence) API endpoint.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPresenceRequest
*/
func (a *ZulipClient) GetPresence(ctx context.Context) ApiGetPresenceRequest {
	return ApiGetPresenceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPresence200Response
func (a *ZulipClient) GetPresenceExecute(r ApiGetPresenceRequest) (*models.GetPresence200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.GetPresence200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/presence"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRealmExportConsentsRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
}

func (r ApiGetRealmExportConsentsRequest) Execute() (*models.GetRealmExportConsents200Response, *http.Response, error) {
	return r.ApiService.GetRealmExportConsentsExecute(r)
}

/*
GetRealmExportConsents Get data export consent state

Fetches which users have [consented](/help/export-your-organization#configure-whether-administrators-can-export-your-private-data)
for their private data to be exported by organization administrators.

**Changes**: New in Zulip 10.0 (feature level 295).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRealmExportConsentsRequest
*/
func (a *ZulipClient) GetRealmExportConsents(ctx context.Context) ApiGetRealmExportConsentsRequest {
	return ApiGetRealmExportConsentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRealmExportConsents200Response
func (a *ZulipClient) GetRealmExportConsentsExecute(r ApiGetRealmExportConsentsRequest) (*models.GetRealmExportConsents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.GetRealmExportConsents200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/export/realm/consents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRealmExportsRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
}

func (r ApiGetRealmExportsRequest) Execute() (*models.GetRealmExports200Response, *http.Response, error) {
	return r.ApiService.GetRealmExportsExecute(r)
}

/*
GetRealmExports Get all data exports

Fetch all the public and standard [data exports][export-data]
of the organization.

**Changes**: Prior to Zulip 10.0 (feature level 304), only
public data exports could be fetched using this endpoint.

New in Zulip 2.1.

[export-data]: /help/export-your-organization#export-for-migrating-to-zulip-cloud-or-a-self-hosted-server


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRealmExportsRequest
*/
func (a *ZulipClient) GetRealmExports(ctx context.Context) ApiGetRealmExportsRequest {
	return ApiGetRealmExportsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRealmExports200Response
func (a *ZulipClient) GetRealmExportsExecute(r ApiGetRealmExportsRequest) (*models.GetRealmExports200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.GetRealmExports200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/export/realm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServerSettingsRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
}

func (r ApiGetServerSettingsRequest) Execute() (*models.GetServerSettings200Response, *http.Response, error) {
	return r.ApiService.GetServerSettingsExecute(r)
}

/*
GetServerSettings Get server settings

Fetch global settings for a Zulip server.

**Note:** this endpoint does not require any authentication at all, and you can use it to check:

- If this is a Zulip server, and if so, what version of Zulip it's running.
- What a Zulip client (e.g. a mobile app or
  [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to
  know in order to display a login prompt for the server (e.g. what
  authentication methods are available).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServerSettingsRequest
*/
func (a *ZulipClient) GetServerSettings(ctx context.Context) ApiGetServerSettingsRequest {
	return ApiGetServerSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetServerSettings200Response
func (a *ZulipClient) GetServerSettingsExecute(r ApiGetServerSettingsRequest) (*models.GetServerSettings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.GetServerSettings200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/server_settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveCodePlaygroundRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	playgroundId int32
}

func (r ApiRemoveCodePlaygroundRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.RemoveCodePlaygroundExecute(r)
}

/*
RemoveCodePlayground Remove a code playground

Remove a [code playground](/help/code-blocks#code-playgrounds) previously
configured for an organization.

**Changes**: New in Zulip 4.0 (feature level 49).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playgroundId The ID of the playground that you want to remove. 
 @return ApiRemoveCodePlaygroundRequest
*/
func (a *ZulipClient) RemoveCodePlayground(ctx context.Context, playgroundId int32) ApiRemoveCodePlaygroundRequest {
	return ApiRemoveCodePlaygroundRequest{
		ApiService: a,
		ctx: ctx,
		playgroundId: playgroundId,
	}
}

// Execute executes the request
//  @return JsonSuccess
func (a *ZulipClient) RemoveCodePlaygroundExecute(r ApiRemoveCodePlaygroundRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.JsonSuccess
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/playgrounds/{playground_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"playground_id"+"}", url.PathEscape(parameterValueToString(r.playgroundId, "playgroundId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveLinkifierRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	filterId int32
}

func (r ApiRemoveLinkifierRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.RemoveLinkifierExecute(r)
}

/*
RemoveLinkifier Remove a linkifier

Remove [linkifiers](/help/add-a-custom-linkifier), regular
expression patterns that are automatically linkified when they appear
in messages and topics.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param filterId The ID of the linkifier that you want to remove. 
 @return ApiRemoveLinkifierRequest
*/
func (a *ZulipClient) RemoveLinkifier(ctx context.Context, filterId int32) ApiRemoveLinkifierRequest {
	return ApiRemoveLinkifierRequest{
		ApiService: a,
		ctx: ctx,
		filterId: filterId,
	}
}

// Execute executes the request
//  @return JsonSuccess
func (a *ZulipClient) RemoveLinkifierExecute(r ApiRemoveLinkifierRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.JsonSuccess
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/filters/{filter_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"filter_id"+"}", url.PathEscape(parameterValueToString(r.filterId, "filterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReorderCustomProfileFieldsRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	order *[]int32
}

// A list of the IDs of all the custom profile fields defined in this organization, in the desired new order. 
func (r ApiReorderCustomProfileFieldsRequest) Order(order []int32) ApiReorderCustomProfileFieldsRequest {
	r.order = &order
	return r
}

func (r ApiReorderCustomProfileFieldsRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.ReorderCustomProfileFieldsExecute(r)
}

/*
ReorderCustomProfileFields Reorder custom profile fields

Reorder the custom profile fields in the user's organization.

Custom profile fields are displayed in Zulip UI widgets in order; this
endpoint allows administrative settings UI to change the field ordering.

This endpoint is used to implement the dragging feature described in the
[custom profile fields documentation](/help/custom-profile-fields).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReorderCustomProfileFieldsRequest
*/
func (a *ZulipClient) ReorderCustomProfileFields(ctx context.Context) ApiReorderCustomProfileFieldsRequest {
	return ApiReorderCustomProfileFieldsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JsonSuccess
func (a *ZulipClient) ReorderCustomProfileFieldsExecute(r ApiReorderCustomProfileFieldsRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.JsonSuccess
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/profile_fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.order == nil {
		return localVarReturnValue, nil, reportError("order is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "order", r.order, "form", "multi")
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReorderLinkifiersRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	orderedLinkifierIds *[]int32
}

// A list of the IDs of all the linkifiers defined in this organization, in the desired new order. 
func (r ApiReorderLinkifiersRequest) OrderedLinkifierIds(orderedLinkifierIds []int32) ApiReorderLinkifiersRequest {
	r.orderedLinkifierIds = &orderedLinkifierIds
	return r
}

func (r ApiReorderLinkifiersRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.ReorderLinkifiersExecute(r)
}

/*
ReorderLinkifiers Reorder linkifiers

Change the order that the regular expression patterns in the organization's
[linkifiers](/help/add-a-custom-linkifier) are matched in messages and topics.
Useful when defining linkifiers with overlapping patterns.

**Changes**: New in Zulip 8.0 (feature level 202). Before this feature level,
linkifiers were always processed in order by ID, which meant users would
need to delete and recreate them to reorder the list of linkifiers.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReorderLinkifiersRequest
*/
func (a *ZulipClient) ReorderLinkifiers(ctx context.Context) ApiReorderLinkifiersRequest {
	return ApiReorderLinkifiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JsonSuccess
func (a *ZulipClient) ReorderLinkifiersExecute(r ApiReorderLinkifiersRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.JsonSuccess
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/linkifiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderedLinkifierIds == nil {
		return localVarReturnValue, nil, reportError("orderedLinkifierIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "ordered_linkifier_ids", r.orderedLinkifierIds, "form", "multi")
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestWelcomeBotCustomMessageRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	welcomeMessageCustomText *string
}

// Custom message text, in Zulip Markdown format, to be used for this test message.  Maximum length is 8000 characters. 
func (r ApiTestWelcomeBotCustomMessageRequest) WelcomeMessageCustomText(welcomeMessageCustomText string) ApiTestWelcomeBotCustomMessageRequest {
	r.welcomeMessageCustomText = &welcomeMessageCustomText
	return r
}

func (r ApiTestWelcomeBotCustomMessageRequest) Execute() (*models.TestWelcomeBotCustomMessage200Response, *http.Response, error) {
	return r.ApiService.TestWelcomeBotCustomMessageExecute(r)
}

/*
TestWelcomeBotCustomMessage Test welcome bot custom message

Sends a test Welcome Bot custom message to the acting administrator.
This allows administrators to preview how the custom welcome message will
appear when received by new users upon joining the organization.

**Changes**: New in Zulip 11.0 (feature level 416).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestWelcomeBotCustomMessageRequest
*/
func (a *ZulipClient) TestWelcomeBotCustomMessage(ctx context.Context) ApiTestWelcomeBotCustomMessageRequest {
	return ApiTestWelcomeBotCustomMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TestWelcomeBotCustomMessage200Response
func (a *ZulipClient) TestWelcomeBotCustomMessageExecute(r ApiTestWelcomeBotCustomMessageRequest) (*models.TestWelcomeBotCustomMessage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.TestWelcomeBotCustomMessage200Response
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/test_welcome_bot_custom_message"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.welcomeMessageCustomText == nil {
		return localVarReturnValue, nil, reportError("welcomeMessageCustomText is required and must be specified")
	}
	if strlen(*r.welcomeMessageCustomText) > 8000 {
		return localVarReturnValue, nil, reportError("welcomeMessageCustomText must have less than 8000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "welcome_message_custom_text", r.welcomeMessageCustomText, "", "")
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLinkifierRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	filterId int32
	pattern *string
	urlTemplate *string
}

// The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
func (r ApiUpdateLinkifierRequest) Pattern(pattern string) ApiUpdateLinkifierRequest {
	r.pattern = &pattern
	return r
}

// The [RFC 6570](https://www.rfc-editor.org/rfc/rfc6570.html) compliant URL template used for the link. If you used named groups in &#x60;pattern&#x60;, you can insert their content here with &#x60;{name_of_group}&#x60;.  **Changes**: New in Zulip 7.0 (feature level 176). This replaced the &#x60;url_format_string&#x60; parameter, which was a format string in which named groups&#39; content could be inserted with &#x60;%(name_of_group)s&#x60;. 
func (r ApiUpdateLinkifierRequest) UrlTemplate(urlTemplate string) ApiUpdateLinkifierRequest {
	r.urlTemplate = &urlTemplate
	return r
}

func (r ApiUpdateLinkifierRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.UpdateLinkifierExecute(r)
}

/*
UpdateLinkifier Update a linkifier

Update a [linkifier](/help/add-a-custom-linkifier), regular
expression patterns that are automatically linkified when they appear
in messages and topics.

**Changes**: New in Zulip 4.0 (feature level 57).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param filterId The ID of the linkifier that you want to update. 
 @return ApiUpdateLinkifierRequest
*/
func (a *ZulipClient) UpdateLinkifier(ctx context.Context, filterId int32) ApiUpdateLinkifierRequest {
	return ApiUpdateLinkifierRequest{
		ApiService: a,
		ctx: ctx,
		filterId: filterId,
	}
}

// Execute executes the request
//  @return JsonSuccess
func (a *ZulipClient) UpdateLinkifierExecute(r ApiUpdateLinkifierRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.JsonSuccess
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/filters/{filter_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"filter_id"+"}", url.PathEscape(parameterValueToString(r.filterId, "filterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pattern == nil {
		return localVarReturnValue, nil, reportError("pattern is required and must be specified")
	}
	if r.urlTemplate == nil {
		return localVarReturnValue, nil, reportError("urlTemplate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pattern", r.pattern, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "url_template", r.urlTemplate, "", "")
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRealmUserSettingsDefaultsRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	starredMessageCounts *bool
	receivesTypingNotifications *bool
	webSuggestUpdateTimezone *bool
	fluidLayoutWidth *bool
	highContrastMode *bool
	webMarkReadOnScrollPolicy *int32
	webChannelDefaultView *int32
	webFontSizePx *int32
	webLineHeightPercent *int32
	colorScheme *int32
	enableDraftsSynchronization *bool
	translateEmoticons *bool
	displayEmojiReactionUsers *bool
	webHomeView *string
	webEscapeNavigatesToHomeView *bool
	leftSideUserlist *bool
	emojiset *string
	demoteInactiveStreams *int32
	userListStyle *int32
	webAnimateImagePreviews *string
	webStreamUnreadsCountDisplayPolicy *int32
	hideAiFeatures *bool
	webLeftSidebarShowChannelFolders *bool
	webLeftSidebarUnreadsCountSummary *bool
	enableStreamDesktopNotifications *bool
	enableStreamEmailNotifications *bool
	enableStreamPushNotifications *bool
	enableStreamAudibleNotifications *bool
	notificationSound *string
	enableDesktopNotifications *bool
	enableSounds *bool
	enableFollowedTopicDesktopNotifications *bool
	enableFollowedTopicEmailNotifications *bool
	enableFollowedTopicPushNotifications *bool
	enableFollowedTopicAudibleNotifications *bool
	emailNotificationsBatchingPeriodSeconds *int32
	enableOfflineEmailNotifications *bool
	enableOfflinePushNotifications *bool
	enableOnlinePushNotifications *bool
	enableDigestEmails *bool
	messageContentInEmailNotifications *bool
	pmContentInDesktopNotifications *bool
	wildcardMentionsNotify *bool
	enableFollowedTopicWildcardMentionsNotify *bool
	desktopIconCountDisplay *int32
	realmNameInEmailNotificationsPolicy *int32
	automaticallyFollowTopicsPolicy *int32
	automaticallyUnmuteTopicsInMutedStreamsPolicy *int32
	automaticallyFollowTopicsWhereMentioned *bool
	resolvedTopicNoticeAutoReadPolicy *string
	presenceEnabled *bool
	enterSends *bool
	twentyFourHourTime *bool
	sendPrivateTypingNotifications *bool
	sendStreamTypingNotifications *bool
	sendReadReceipts *bool
	emailAddressVisibility *int32
	webNavigateToSentMessage *bool
}

// Whether clients should display the [number of starred messages](/help/star-a-message#display-the-number-of-starred-messages). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) StarredMessageCounts(starredMessageCounts bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.starredMessageCounts = &starredMessageCounts
	return r
}

// Whether the user is configured to receive typing notifications from other users. The server will only deliver typing notifications events to users who for whom this is enabled.  **Changes**: New in Zulip 9.0 (feature level 253). Previously, there were only options to disable sending typing notifications. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) ReceivesTypingNotifications(receivesTypingNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.receivesTypingNotifications = &receivesTypingNotifications
	return r
}

// Whether the user should be shown an alert, offering to update their [profile time zone](/help/change-your-timezone), when the time displayed for the profile time zone differs from the current time displayed by the time zone configured on their device.  **Changes**: New in Zulip 10.0 (feature level 329). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebSuggestUpdateTimezone(webSuggestUpdateTimezone bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webSuggestUpdateTimezone = &webSuggestUpdateTimezone
	return r
}

// Whether to use the [maximum available screen width](/help/enable-full-width-display) for the web app&#39;s center panel (message feed, recent conversations) on wide screens. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) FluidLayoutWidth(fluidLayoutWidth bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.fluidLayoutWidth = &fluidLayoutWidth
	return r
}

// This setting is reserved for use to control variations in Zulip&#39;s design to help visually impaired users. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) HighContrastMode(highContrastMode bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.highContrastMode = &highContrastMode
	return r
}

// Whether or not to mark messages as read when the user scrolls through their feed.  - 1 - Always - 2 - Only in conversation views - 3 - Never  **Changes**: New in Zulip 7.0 (feature level 175). Previously, there was no way for the user to configure this behavior on the web, and the Zulip web and desktop apps behaved like the \\\&quot;Always\\\&quot; setting when marking messages as read. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebMarkReadOnScrollPolicy(webMarkReadOnScrollPolicy int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webMarkReadOnScrollPolicy = &webMarkReadOnScrollPolicy
	return r
}

// Web/desktop app setting controlling the default navigation behavior when clicking on a channel link.  - 1 - Top topic in the channel - 2 - Channel feed - 3 - List of topics - 4 - Top unread topic in channel  **Changes**: The \\\&quot;Top unread topic in channel\\\&quot; is new in Zulip 11.0 (feature level 401).  The \\\&quot;List of topics\\\&quot; option is new in Zulip 11.0 (feature level 383).  New in Zulip 9.0 (feature level 269). Previously, this was not configurable, and every user had the \\\&quot;Channel feed\\\&quot; behavior. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebChannelDefaultView(webChannelDefaultView int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webChannelDefaultView = &webChannelDefaultView
	return r
}

// User-configured primary &#x60;font-size&#x60; for the web application, in pixels.  **Changes**: New in Zulip 9.0 (feature level 245). Previously, font size was only adjustable via browser zoom. Note that this setting was not fully implemented at this feature level. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebFontSizePx(webFontSizePx int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webFontSizePx = &webFontSizePx
	return r
}

// User-configured primary &#x60;line-height&#x60; for the web application, in percent, so a value of 120 represents a &#x60;line-height&#x60; of 1.2.  **Changes**: New in Zulip 9.0 (feature level 245). Previously, line height was not user-configurable. Note that this setting was not fully implemented at this feature level. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebLineHeightPercent(webLineHeightPercent int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webLineHeightPercent = &webLineHeightPercent
	return r
}

// Controls which [color theme](/help/dark-theme) to use.  - 1 - Automatic - 2 - Dark theme - 3 - Light theme  Automatic detection is implementing using the standard &#x60;prefers-color-scheme&#x60; media query. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) ColorScheme(colorScheme int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.colorScheme = &colorScheme
	return r
}

// A boolean parameter to control whether synchronizing drafts is enabled for the user. When synchronization is disabled, all drafts stored in the server will be automatically deleted from the server.  This does not do anything (like sending events) to delete local copies of drafts stored in clients. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableDraftsSynchronization(enableDraftsSynchronization bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableDraftsSynchronization = &enableDraftsSynchronization
	return r
}

// Whether to [translate emoticons to emoji](/help/configure-emoticon-translations) in messages the user sends. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) TranslateEmoticons(translateEmoticons bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.translateEmoticons = &translateEmoticons
	return r
}

// Whether to display the names of reacting users on a message.  When enabled, clients should display the names of reacting users, rather than a count, for messages with few total reactions. The ideal cutoff may depend on the space available for displaying reactions; the official web application displays names when 3 or fewer total reactions are present with this setting enabled.  **Changes**: New in Zulip 6.0 (feature level 125). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) DisplayEmojiReactionUsers(displayEmojiReactionUsers bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.displayEmojiReactionUsers = &displayEmojiReactionUsers
	return r
}

// The [home view](/help/configure-home-view) used when opening a new Zulip web app window or hitting the &#x60;Esc&#x60; keyboard shortcut repeatedly.  - \\\&quot;recent_topics\\\&quot; - Recent conversations view - \\\&quot;inbox\\\&quot; - Inbox view - \\\&quot;all_messages\\\&quot; - Combined feed view  **Changes**: New in Zulip 8.0 (feature level 219). Previously, this was called &#x60;default_view&#x60;, which was new in Zulip 4.0 (feature level 42). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebHomeView(webHomeView string) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webHomeView = &webHomeView
	return r
}

// Whether the escape key navigates to the [configured home view](/help/configure-home-view).  **Changes**: New in Zulip 8.0 (feature level 219). Previously, this was called &#x60;escape_navigates_to_default_view&#x60;, which was new in Zulip 5.0 (feature level 107). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebEscapeNavigatesToHomeView(webEscapeNavigatesToHomeView bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webEscapeNavigatesToHomeView = &webEscapeNavigatesToHomeView
	return r
}

// Whether the users list on left sidebar in narrow windows.  This feature is not heavily used and is likely to be reworked. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) LeftSideUserlist(leftSideUserlist bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.leftSideUserlist = &leftSideUserlist
	return r
}

// The user&#39;s configured [emoji set](/help/emoji-and-emoticons#use-emoticons), used to display emoji to the user everywhere they appear in the UI.  - \\\&quot;google\\\&quot; - Google - \\\&quot;twitter\\\&quot; - Twitter - \\\&quot;text\\\&quot; - Plain text - \\\&quot;google-blob\\\&quot; - Google blobs 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) Emojiset(emojiset string) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.emojiset = &emojiset
	return r
}

// Whether to [hide inactive channels](/help/manage-inactive-channels) in the left sidebar.  - 1 - Automatic - 2 - Always - 3 - Never 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) DemoteInactiveStreams(demoteInactiveStreams int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.demoteInactiveStreams = &demoteInactiveStreams
	return r
}

// The style selected by the user for the right sidebar user list.  - 1 - Compact - 2 - With status - 3 - With avatar and status  **Changes**: New in Zulip 6.0 (feature level 141). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) UserListStyle(userListStyle int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.userListStyle = &userListStyle
	return r
}

// Controls how animated images should be played in the message feed in the web/desktop application.  - \\\&quot;always\\\&quot; - Always play the animated images in the message feed. - \\\&quot;on_hover\\\&quot; - Play the animated images on hover over them in the message feed. - \\\&quot;never\\\&quot; - Never play animated images in the message feed.  **Changes**: New in Zulip 9.0 (feature level 275). Previously, animated images always used to play in the message feed by default. This setting controls this behaviour. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebAnimateImagePreviews(webAnimateImagePreviews string) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webAnimateImagePreviews = &webAnimateImagePreviews
	return r
}

// Configuration for which channels should be displayed with a numeric unread count in the left sidebar. Channels that do not have an unread count will have a simple dot indicator for whether there are any unread messages.  - 1 - All channels - 2 - Unmuted channels and topics - 3 - No channels  **Changes**: New in Zulip 8.0 (feature level 210). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebStreamUnreadsCountDisplayPolicy(webStreamUnreadsCountDisplayPolicy int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webStreamUnreadsCountDisplayPolicy = &webStreamUnreadsCountDisplayPolicy
	return r
}

// Controls whether user wants AI features like topic summarization to be hidden in all Zulip clients.  **Changes**: New in Zulip 10.0 (feature level 350). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) HideAiFeatures(hideAiFeatures bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.hideAiFeatures = &hideAiFeatures
	return r
}

// Determines whether the web/desktop application&#39;s left sidebar displays any channel folders configured by the organization.  **Changes**: New in Zulip 11.0 (feature level 411). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebLeftSidebarShowChannelFolders(webLeftSidebarShowChannelFolders bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webLeftSidebarShowChannelFolders = &webLeftSidebarShowChannelFolders
	return r
}

// Determines whether the web/desktop application&#39;s left sidebar displays the unread message count summary.  **Changes**: New in Zulip 11.0 (feature level 398). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebLeftSidebarUnreadsCountSummary(webLeftSidebarUnreadsCountSummary bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webLeftSidebarUnreadsCountSummary = &webLeftSidebarUnreadsCountSummary
	return r
}

// Enable visual desktop notifications for channel messages. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableStreamDesktopNotifications(enableStreamDesktopNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableStreamDesktopNotifications = &enableStreamDesktopNotifications
	return r
}

// Enable email notifications for channel messages. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableStreamEmailNotifications(enableStreamEmailNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableStreamEmailNotifications = &enableStreamEmailNotifications
	return r
}

// Enable mobile notifications for channel messages. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableStreamPushNotifications(enableStreamPushNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableStreamPushNotifications = &enableStreamPushNotifications
	return r
}

// Enable audible desktop notifications for channel messages. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableStreamAudibleNotifications(enableStreamAudibleNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableStreamAudibleNotifications = &enableStreamAudibleNotifications
	return r
}

// Notification sound name. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) NotificationSound(notificationSound string) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.notificationSound = &notificationSound
	return r
}

// Enable visual desktop notifications for direct messages and @-mentions. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableDesktopNotifications(enableDesktopNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableDesktopNotifications = &enableDesktopNotifications
	return r
}

// Enable audible desktop notifications for direct messages and @-mentions. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableSounds(enableSounds bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableSounds = &enableSounds
	return r
}

// Enable visual desktop notifications for messages sent to followed topics.  **Changes**: New in Zulip 8.0 (feature level 189). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableFollowedTopicDesktopNotifications(enableFollowedTopicDesktopNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableFollowedTopicDesktopNotifications = &enableFollowedTopicDesktopNotifications
	return r
}

// Enable email notifications for messages sent to followed topics.  **Changes**: New in Zulip 8.0 (feature level 189). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableFollowedTopicEmailNotifications(enableFollowedTopicEmailNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableFollowedTopicEmailNotifications = &enableFollowedTopicEmailNotifications
	return r
}

// Enable push notifications for messages sent to followed topics.  **Changes**: New in Zulip 8.0 (feature level 189). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableFollowedTopicPushNotifications(enableFollowedTopicPushNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableFollowedTopicPushNotifications = &enableFollowedTopicPushNotifications
	return r
}

// Enable audible desktop notifications for messages sent to followed topics.  **Changes**: New in Zulip 8.0 (feature level 189). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableFollowedTopicAudibleNotifications(enableFollowedTopicAudibleNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableFollowedTopicAudibleNotifications = &enableFollowedTopicAudibleNotifications
	return r
}

// The duration (in seconds) for which the server should wait to batch email notifications before sending them. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EmailNotificationsBatchingPeriodSeconds(emailNotificationsBatchingPeriodSeconds int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.emailNotificationsBatchingPeriodSeconds = &emailNotificationsBatchingPeriodSeconds
	return r
}

// Enable email notifications for direct messages and @-mentions received when the user is offline. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableOfflineEmailNotifications(enableOfflineEmailNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableOfflineEmailNotifications = &enableOfflineEmailNotifications
	return r
}

// Enable mobile notification for direct messages and @-mentions received when the user is offline. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableOfflinePushNotifications(enableOfflinePushNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableOfflinePushNotifications = &enableOfflinePushNotifications
	return r
}

// Enable mobile notification for direct messages and @-mentions received when the user is online. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableOnlinePushNotifications(enableOnlinePushNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableOnlinePushNotifications = &enableOnlinePushNotifications
	return r
}

// Enable digest emails when the user is away. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableDigestEmails(enableDigestEmails bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableDigestEmails = &enableDigestEmails
	return r
}

// Include the message&#39;s content in email notifications for new messages. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) MessageContentInEmailNotifications(messageContentInEmailNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.messageContentInEmailNotifications = &messageContentInEmailNotifications
	return r
}

// Include content of direct messages in desktop notifications. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) PmContentInDesktopNotifications(pmContentInDesktopNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.pmContentInDesktopNotifications = &pmContentInDesktopNotifications
	return r
}

// Whether wildcard mentions (E.g. @**all**) should send notifications like a personal mention. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WildcardMentionsNotify(wildcardMentionsNotify bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.wildcardMentionsNotify = &wildcardMentionsNotify
	return r
}

// Whether wildcard mentions (e.g., @**all**) in messages sent to followed topics should send notifications like a personal mention.  **Changes**: New in Zulip 8.0 (feature level 189). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnableFollowedTopicWildcardMentionsNotify(enableFollowedTopicWildcardMentionsNotify bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enableFollowedTopicWildcardMentionsNotify = &enableFollowedTopicWildcardMentionsNotify
	return r
}

// Unread count badge (appears in desktop sidebar and browser tab)  - 1 - All unread messages - 2 - DMs, mentions, and followed topics - 3 - DMs and mentions - 4 - None  **Changes**: In Zulip 8.0 (feature level 227), added &#x60;DMs, mentions, and followed topics&#x60; option, renumbering the options to insert it in order. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) DesktopIconCountDisplay(desktopIconCountDisplay int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.desktopIconCountDisplay = &desktopIconCountDisplay
	return r
}

// Whether to [include organization name in subject of message notification emails](/help/email-notifications#include-organization-name-in-subject-line).  - 1 - Automatic - 2 - Always - 3 - Never  **Changes**: New in Zulip 7.0 (feature level 168), replacing the previous &#x60;realm_name_in_notifications&#x60; boolean; &#x60;true&#x60; corresponded to &#x60;Always&#x60;, and &#x60;false&#x60; to &#x60;Never&#x60;. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) RealmNameInEmailNotificationsPolicy(realmNameInEmailNotificationsPolicy int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.realmNameInEmailNotificationsPolicy = &realmNameInEmailNotificationsPolicy
	return r
}

// Which [topics to follow automatically](/help/mute-a-topic).  - 1 - Topics the user participates in - 2 - Topics the user sends a message to - 3 - Topics the user starts - 4 - Never  **Changes**: New in Zulip 8.0 (feature level 214). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) AutomaticallyFollowTopicsPolicy(automaticallyFollowTopicsPolicy int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.automaticallyFollowTopicsPolicy = &automaticallyFollowTopicsPolicy
	return r
}

// Which [topics to unmute automatically in muted channels](/help/mute-a-topic).  - 1 - Topics the user participates in - 2 - Topics the user sends a message to - 3 - Topics the user starts - 4 - Never  **Changes**: New in Zulip 8.0 (feature level 214). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) AutomaticallyUnmuteTopicsInMutedStreamsPolicy(automaticallyUnmuteTopicsInMutedStreamsPolicy int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.automaticallyUnmuteTopicsInMutedStreamsPolicy = &automaticallyUnmuteTopicsInMutedStreamsPolicy
	return r
}

// Whether the server will automatically mark the user as following topics where the user is mentioned.  **Changes**: New in Zulip 8.0 (feature level 235). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) AutomaticallyFollowTopicsWhereMentioned(automaticallyFollowTopicsWhereMentioned bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.automaticallyFollowTopicsWhereMentioned = &automaticallyFollowTopicsWhereMentioned
	return r
}

// Controls whether the resolved-topic notices are marked as read.  - \\\&quot;always\\\&quot; - Always mark resolved-topic notices as read. - \\\&quot;except_followed\\\&quot; - Mark resolved-topic notices as read in topics not followed by the user. - \\\&quot;never\\\&quot; - Never mark resolved-topic notices as read.  **Changes**: New in Zulip 11.0 (feature level 385). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) ResolvedTopicNoticeAutoReadPolicy(resolvedTopicNoticeAutoReadPolicy string) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.resolvedTopicNoticeAutoReadPolicy = &resolvedTopicNoticeAutoReadPolicy
	return r
}

// Display the presence status to other users when online. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) PresenceEnabled(presenceEnabled bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.presenceEnabled = &presenceEnabled
	return r
}

// Whether pressing Enter in the compose box sends a message (or saves a message edit). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EnterSends(enterSends bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.enterSends = &enterSends
	return r
}

// Whether time should be [displayed in 24-hour notation](/help/change-the-time-format).  **Changes**: New in Zulip 5.0 (feature level 99). Previously, this default was edited using the &#x60;default_twenty_four_hour_time&#x60; parameter to the &#x60;PATCH /realm&#x60; endpoint. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) TwentyFourHourTime(twentyFourHourTime bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.twentyFourHourTime = &twentyFourHourTime
	return r
}

// Whether [typing notifications](/help/typing-notifications) be sent when composing direct messages.  **Changes**: New in Zulip 5.0 (feature level 105). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) SendPrivateTypingNotifications(sendPrivateTypingNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.sendPrivateTypingNotifications = &sendPrivateTypingNotifications
	return r
}

// Whether [typing notifications](/help/typing-notifications) be sent when composing channel messages.  **Changes**: New in Zulip 5.0 (feature level 105). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) SendStreamTypingNotifications(sendStreamTypingNotifications bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.sendStreamTypingNotifications = &sendStreamTypingNotifications
	return r
}

// Whether other users are allowed to see whether you&#39;ve read messages.  **Changes**: New in Zulip 5.0 (feature level 105). 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) SendReadReceipts(sendReadReceipts bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.sendReadReceipts = &sendReadReceipts
	return r
}

// The [policy][permission-level] for [which other users][help-email-visibility] in this organization can see the user&#39;s real email address.  - 1 &#x3D; Everyone - 2 &#x3D; Members only - 3 &#x3D; Administrators only - 4 &#x3D; Nobody - 5 &#x3D; Moderators only  **Changes**: New in Zulip 7.0 (feature level 163), replacing the realm-level setting.  [permission-level]: /api/roles-and-permissions#permission-levels [help-email-visibility]: /help/configure-email-visibility 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) EmailAddressVisibility(emailAddressVisibility int32) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.emailAddressVisibility = &emailAddressVisibility
	return r
}

// Web/desktop app setting for whether the user&#39;s view should automatically go to the conversation where they sent a message.  **Changes**: New in Zulip 9.0 (feature level 268). Previously, this behavior was not configurable. 
func (r ApiUpdateRealmUserSettingsDefaultsRequest) WebNavigateToSentMessage(webNavigateToSentMessage bool) ApiUpdateRealmUserSettingsDefaultsRequest {
	r.webNavigateToSentMessage = &webNavigateToSentMessage
	return r
}

func (r ApiUpdateRealmUserSettingsDefaultsRequest) Execute() (*models.IgnoredParametersSuccess, *http.Response, error) {
	return r.ApiService.UpdateRealmUserSettingsDefaultsExecute(r)
}

/*
UpdateRealmUserSettingsDefaults Update realm-level defaults of user settings

Change the [default values of settings][new-user-defaults] for new users
joining the organization. Essentially all
[personal preference settings](/api/update-settings) are supported.

This feature can be invaluable for customizing Zulip's default
settings for notifications or UI to be appropriate for how the
organization is using Zulip. (Note that this only supports
personal preference settings, like when to send push
notifications or what emoji set to use, not profile or
identity settings that naturally should be different for each user).

Note that this endpoint cannot, at present, be used to modify
settings for existing users in any way.

**Changes**: Removed `dense_mode` setting in Zulip 10.0 (feature level 364)
as we now have `web_font_size_px` and `web_line_height_percent`
settings for more control.

New in Zulip 5.0 (feature level 96). If any parameters sent in the
request are not supported by this endpoint, an
[`ignored_parameters_unsupported`][ignored-parameters] array will
be returned in the JSON success response.

[new-user-defaults]: /help/configure-default-new-user-settings
[ignored-parameters]: /api/rest-error-handling#ignored-parameters


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateRealmUserSettingsDefaultsRequest
*/
func (a *ZulipClient) UpdateRealmUserSettingsDefaults(ctx context.Context) ApiUpdateRealmUserSettingsDefaultsRequest {
	return ApiUpdateRealmUserSettingsDefaultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IgnoredParametersSuccess
func (a *ZulipClient) UpdateRealmUserSettingsDefaultsExecute(r ApiUpdateRealmUserSettingsDefaultsRequest) (*models.IgnoredParametersSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.IgnoredParametersSuccess
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/user_settings_defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.starredMessageCounts != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "starred_message_counts", r.starredMessageCounts, "form", "")
	}
	if r.receivesTypingNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "receives_typing_notifications", r.receivesTypingNotifications, "form", "")
	}
	if r.webSuggestUpdateTimezone != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_suggest_update_timezone", r.webSuggestUpdateTimezone, "form", "")
	}
	if r.fluidLayoutWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fluid_layout_width", r.fluidLayoutWidth, "form", "")
	}
	if r.highContrastMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "high_contrast_mode", r.highContrastMode, "form", "")
	}
	if r.webMarkReadOnScrollPolicy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_mark_read_on_scroll_policy", r.webMarkReadOnScrollPolicy, "form", "")
	}
	if r.webChannelDefaultView != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_channel_default_view", r.webChannelDefaultView, "form", "")
	}
	if r.webFontSizePx != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_font_size_px", r.webFontSizePx, "form", "")
	}
	if r.webLineHeightPercent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_line_height_percent", r.webLineHeightPercent, "form", "")
	}
	if r.colorScheme != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "color_scheme", r.colorScheme, "form", "")
	}
	if r.enableDraftsSynchronization != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_drafts_synchronization", r.enableDraftsSynchronization, "form", "")
	}
	if r.translateEmoticons != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "translate_emoticons", r.translateEmoticons, "form", "")
	}
	if r.displayEmojiReactionUsers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "display_emoji_reaction_users", r.displayEmojiReactionUsers, "form", "")
	}
	if r.webHomeView != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_home_view", r.webHomeView, "", "")
	}
	if r.webEscapeNavigatesToHomeView != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_escape_navigates_to_home_view", r.webEscapeNavigatesToHomeView, "form", "")
	}
	if r.leftSideUserlist != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "left_side_userlist", r.leftSideUserlist, "form", "")
	}
	if r.emojiset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "emojiset", r.emojiset, "", "")
	}
	if r.demoteInactiveStreams != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "demote_inactive_streams", r.demoteInactiveStreams, "form", "")
	}
	if r.userListStyle != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "user_list_style", r.userListStyle, "form", "")
	}
	if r.webAnimateImagePreviews != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_animate_image_previews", r.webAnimateImagePreviews, "", "")
	}
	if r.webStreamUnreadsCountDisplayPolicy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_stream_unreads_count_display_policy", r.webStreamUnreadsCountDisplayPolicy, "form", "")
	}
	if r.hideAiFeatures != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "hide_ai_features", r.hideAiFeatures, "form", "")
	}
	if r.webLeftSidebarShowChannelFolders != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_left_sidebar_show_channel_folders", r.webLeftSidebarShowChannelFolders, "form", "")
	}
	if r.webLeftSidebarUnreadsCountSummary != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_left_sidebar_unreads_count_summary", r.webLeftSidebarUnreadsCountSummary, "form", "")
	}
	if r.enableStreamDesktopNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_stream_desktop_notifications", r.enableStreamDesktopNotifications, "form", "")
	}
	if r.enableStreamEmailNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_stream_email_notifications", r.enableStreamEmailNotifications, "form", "")
	}
	if r.enableStreamPushNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_stream_push_notifications", r.enableStreamPushNotifications, "form", "")
	}
	if r.enableStreamAudibleNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_stream_audible_notifications", r.enableStreamAudibleNotifications, "form", "")
	}
	if r.notificationSound != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "notification_sound", r.notificationSound, "", "")
	}
	if r.enableDesktopNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_desktop_notifications", r.enableDesktopNotifications, "form", "")
	}
	if r.enableSounds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_sounds", r.enableSounds, "form", "")
	}
	if r.enableFollowedTopicDesktopNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_followed_topic_desktop_notifications", r.enableFollowedTopicDesktopNotifications, "form", "")
	}
	if r.enableFollowedTopicEmailNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_followed_topic_email_notifications", r.enableFollowedTopicEmailNotifications, "form", "")
	}
	if r.enableFollowedTopicPushNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_followed_topic_push_notifications", r.enableFollowedTopicPushNotifications, "form", "")
	}
	if r.enableFollowedTopicAudibleNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_followed_topic_audible_notifications", r.enableFollowedTopicAudibleNotifications, "form", "")
	}
	if r.emailNotificationsBatchingPeriodSeconds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "email_notifications_batching_period_seconds", r.emailNotificationsBatchingPeriodSeconds, "form", "")
	}
	if r.enableOfflineEmailNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_offline_email_notifications", r.enableOfflineEmailNotifications, "form", "")
	}
	if r.enableOfflinePushNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_offline_push_notifications", r.enableOfflinePushNotifications, "form", "")
	}
	if r.enableOnlinePushNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_online_push_notifications", r.enableOnlinePushNotifications, "form", "")
	}
	if r.enableDigestEmails != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_digest_emails", r.enableDigestEmails, "form", "")
	}
	if r.messageContentInEmailNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_content_in_email_notifications", r.messageContentInEmailNotifications, "form", "")
	}
	if r.pmContentInDesktopNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pm_content_in_desktop_notifications", r.pmContentInDesktopNotifications, "form", "")
	}
	if r.wildcardMentionsNotify != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "wildcard_mentions_notify", r.wildcardMentionsNotify, "form", "")
	}
	if r.enableFollowedTopicWildcardMentionsNotify != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_followed_topic_wildcard_mentions_notify", r.enableFollowedTopicWildcardMentionsNotify, "form", "")
	}
	if r.desktopIconCountDisplay != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "desktop_icon_count_display", r.desktopIconCountDisplay, "form", "")
	}
	if r.realmNameInEmailNotificationsPolicy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "realm_name_in_email_notifications_policy", r.realmNameInEmailNotificationsPolicy, "form", "")
	}
	if r.automaticallyFollowTopicsPolicy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "automatically_follow_topics_policy", r.automaticallyFollowTopicsPolicy, "form", "")
	}
	if r.automaticallyUnmuteTopicsInMutedStreamsPolicy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "automatically_unmute_topics_in_muted_streams_policy", r.automaticallyUnmuteTopicsInMutedStreamsPolicy, "form", "")
	}
	if r.automaticallyFollowTopicsWhereMentioned != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "automatically_follow_topics_where_mentioned", r.automaticallyFollowTopicsWhereMentioned, "form", "")
	}
	if r.resolvedTopicNoticeAutoReadPolicy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "resolved_topic_notice_auto_read_policy", r.resolvedTopicNoticeAutoReadPolicy, "", "")
	}
	if r.presenceEnabled != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "presence_enabled", r.presenceEnabled, "form", "")
	}
	if r.enterSends != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enter_sends", r.enterSends, "form", "")
	}
	if r.twentyFourHourTime != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "twenty_four_hour_time", r.twentyFourHourTime, "form", "")
	}
	if r.sendPrivateTypingNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_private_typing_notifications", r.sendPrivateTypingNotifications, "form", "")
	}
	if r.sendStreamTypingNotifications != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_stream_typing_notifications", r.sendStreamTypingNotifications, "form", "")
	}
	if r.sendReadReceipts != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_read_receipts", r.sendReadReceipts, "form", "")
	}
	if r.emailAddressVisibility != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "email_address_visibility", r.emailAddressVisibility, "form", "")
	}
	if r.webNavigateToSentMessage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "web_navigate_to_sent_message", r.webNavigateToSentMessage, "form", "")
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadCustomEmojiRequest struct {
	ctx context.Context
	ApiService ServerAndOrganizationsAPI
	emojiName string
	filename *os.File
}

func (r ApiUploadCustomEmojiRequest) Filename(filename *os.File) ApiUploadCustomEmojiRequest {
	r.filename = filename
	return r
}

func (r ApiUploadCustomEmojiRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.UploadCustomEmojiExecute(r)
}

/*
UploadCustomEmoji Upload custom emoji

This endpoint is used to upload a custom emoji for use in the user's
organization. Access to this endpoint depends on the
[organization's configuration](https://zulip.com/help/custom-emoji#change-who-can-add-custom-emoji).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param emojiName The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (\\_) are treated the same as spaces (consistent with how the Zulip UI handles emoji). 
 @return ApiUploadCustomEmojiRequest
*/
func (a *ZulipClient) UploadCustomEmoji(ctx context.Context, emojiName string) ApiUploadCustomEmojiRequest {
	return ApiUploadCustomEmojiRequest{
		ApiService: a,
		ctx: ctx,
		emojiName: emojiName,
	}
}

// Execute executes the request
//  @return JsonSuccess
func (a *ZulipClient) UploadCustomEmojiExecute(r ApiUploadCustomEmojiRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.JsonSuccess
	)

	localBasePath, err := a.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/realm/emoji/{emoji_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"emoji_name"+"}", url.PathEscape(parameterValueToString(r.emojiName, "emojiName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var filenameLocalVarFormFileName string
	var filenameLocalVarFileName     string
	var filenameLocalVarFileBytes    []byte

	filenameLocalVarFormFileName = "filename"
	filenameLocalVarFile := r.filename

	if filenameLocalVarFile != nil {
		fbs, _ := io.ReadAll(filenameLocalVarFile)

		filenameLocalVarFileBytes = fbs
		filenameLocalVarFileName = filenameLocalVarFile.Name()
		filenameLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: filenameLocalVarFileBytes, fileName: filenameLocalVarFileName, formFileName: filenameLocalVarFormFileName})
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
