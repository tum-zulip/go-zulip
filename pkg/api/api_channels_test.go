/*
Zulip REST API

Testing ChannelsAPIService

*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech);

package api_test

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/tum-zulip/go-zulip/pkg/api"
	"github.com/tum-zulip/go-zulip/pkg/models"
)

func Test_ChannelsAPIService(t *testing.T) {
	t.Run("Admin operations", func(t *testing.T) {
		apiClient := GetAdminClient(t)

		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		t.Run("AddDefaultStream", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)

			resp, httpRes, err := apiClient.AddDefaultStream(ctx).StreamId(streamID).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("ArchiveStream", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)

			resp, httpRes, err := apiClient.ArchiveStream(ctx, streamID).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("CreateChannelFolder", func(t *testing.T) {
			resp, httpRes, err := apiClient.CreateChannelFolder(ctx).
				Name(uniqueName("test-folder")).
				Description("Created during Channels API tests").
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.Greater(t, resp.GetChannelFolderId(), int32(0))
		})

		t.Run("DeleteTopic", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)
			topic := createTopicWithMessage(t, apiClient, streamID)

			resp, httpRes, err := apiClient.DeleteTopic(ctx, streamID).
				TopicName(topic).
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.True(t, resp.GetComplete())
		})

		t.Run("PatchChannelFolders", func(t *testing.T) {
			createChannelFolder(t, apiClient, uniqueName("patch-folder"), "first test folder")
			createChannelFolder(t, apiClient, uniqueName("patch-folder"), "second test folder")

			originalOrder := getChannelFolderIDs(t, apiClient)
			if len(originalOrder) < 2 {
				t.Skip("need at least two channel folders to reorder")
			}

			reordered := append([]int32(nil), originalOrder...)
			reverseInt32Slice(reordered)

			resp, httpRes, err := apiClient.PatchChannelFolders(ctx).
				Order(reordered).
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("RemoveDefaultStream", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)
			reqResp, _, err := apiClient.AddDefaultStream(ctx).StreamId(streamID).Execute()
			require.NoError(t, err)
			require.NotNil(t, reqResp)

			resp, httpRes, err := apiClient.RemoveDefaultStream(ctx).StreamId(streamID).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("UpdateChannelFolder", func(t *testing.T) {
			folderID := createChannelFolder(t, apiClient, uniqueName("update-folder"), "initial description")

			resp, httpRes, err := apiClient.UpdateChannelFolder(ctx, folderID).
				Description("updated folder description").
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("UpdateStream", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)

			resp, httpRes, err := apiClient.UpdateStream(ctx, streamID).
				Description("updated by test").
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})
	})

	runForClients(t, allClients, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		t.Run("CreateBigBlueButtonVideoCall", func(t *testing.T) {
			resp, httpRes, err := apiClient.CreateBigBlueButtonVideoCall(ctx).
				MeetingName(uniqueName("bbb-meeting")).
				Execute()
			if err != nil {
				skipIfBigBlueButtonUnavailable(t, err)
			}
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.NotEmpty(t, resp.GetUrl())
		})

		t.Run("CreateChannel", func(t *testing.T) {
			createRandomChannel(t, apiClient, userId)
		})

		t.Run("GetChannelFolders", func(t *testing.T) {
			resp, httpRes, err := apiClient.GetChannelFolders(ctx).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("GetStreamById", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)

			resp, httpRes, err := apiClient.GetStreamById(ctx, streamID).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			require.True(t, resp.HasStream())
			stream := resp.GetStream()
			assert.Equal(t, streamID, stream.StreamId)
		})

		t.Run("GetStreamEmailAddress", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)

			resp, httpRes, err := apiClient.GetStreamEmailAddress(ctx, streamID).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.NotEmpty(t, resp.GetEmail())
		})

		t.Run("GetStreamId", func(t *testing.T) {
			streamName, streamID := createRandomChannel(t, apiClient, userId)

			resp, httpRes, err := apiClient.GetStreamId(ctx).
				Stream(streamName).
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.Equal(t, streamID, resp.GetStreamId())
		})

		t.Run("GetStreamTopics", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)
			topic := createTopicWithMessage(t, apiClient, streamID)

			resp, httpRes, err := apiClient.GetStreamTopics(ctx, streamID).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)

			found := false
			for _, entry := range resp.GetTopics() {
				if strings.EqualFold(entry.GetName(), topic) {
					found = true
					break
				}
			}
			assert.True(t, found, "expected topic %q in list", topic)
		})

		t.Run("GetStreams", func(t *testing.T) {
			resp, httpRes, err := apiClient.GetStreams(ctx).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.NotEmpty(t, resp.GetStreams())
		})

		t.Run("GetSubscribers", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)

			resp, httpRes, err := apiClient.GetSubscribers(ctx, streamID).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)

			subscribers := resp.GetSubscribers()
			assert.Contains(t, subscribers, userId)
		})

		t.Run("GetSubscriptionStatus", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)

			resp, httpRes, err := apiClient.GetSubscriptionStatus(ctx, userId, streamID).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.True(t, resp.GetIsSubscribed())
		})

		t.Run("GetSubscriptions", func(t *testing.T) {
			resp, httpRes, err := apiClient.GetSubscriptions(ctx).Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.NotEmpty(t, resp.GetSubscriptions())
		})

		t.Run("MuteTopic", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)
			topic := createTopicWithMessage(t, apiClient, streamID)

			resp, httpRes, err := apiClient.MuteTopic(ctx).
				StreamId(streamID).
				Topic(topic).
				Op("add").
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("Subscribe", func(t *testing.T) {
			subscription := models.NewSubscribeRequestSubscriptionsInner(uniqueName("subscribe-stream"))
			subscription.SetDescription("Created via Subscribe test")

			resp, httpRes, err := apiClient.Subscribe(ctx).
				Subscriptions([]models.SubscribeRequestSubscriptionsInner{*subscription}).
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.Equal(t, "success", resp.GetResult())
		})

		t.Run("Unsubscribe", func(t *testing.T) {
			streamName, _ := createRandomChannel(t, apiClient, userId)

			resp, httpRes, err := apiClient.Unsubscribe(ctx).
				Subscriptions([]string{streamName}).
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)

			if len(resp.GetRemoved()) > 0 {
				assert.Contains(t, resp.GetRemoved(), streamName)
			}
		})

		t.Run("UpdateSubscriptionSettings", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)
			mute := true
			update := models.NewUpdateSubscriptionSetting(streamID, "is_muted", models.BoolAsSubscriptionDataValue(&mute))

			resp, httpRes, err := apiClient.UpdateSubscriptionSettings(ctx).
				SubscriptionData([]models.UpdateSubscriptionSetting{*update}).
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("UpdateSubscriptions", func(t *testing.T) {
			streamName := uniqueName("update-subscriptions")
			add := models.NewUpdateSubscriptionsRequestAddInner()
			add.SetName(streamName)
			add.SetDescription("Created in UpdateSubscriptions test")

			resp, httpRes, err := apiClient.UpdateSubscriptions(ctx).
				Add([]models.UpdateSubscriptionsRequestAddInner{*add}).
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.Equal(t, "success", resp.GetResult())
		})

		t.Run("UpdateUserTopic", func(t *testing.T) {
			_, streamID := createRandomChannel(t, apiClient, userId)
			topic := createTopicWithMessage(t, apiClient, streamID)

			resp, httpRes, err := apiClient.UpdateUserTopic(ctx).
				StreamId(streamID).
				Topic(topic).
				VisibilityPolicy(1).
				Execute()
			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})
	})
}

func createRandomChannel(t *testing.T, apiClient *api.ZulipClient, subscribers ...int32) (string, int32) {
	t.Helper()

	subs := append([]int32(nil), subscribers...)
	if len(subs) == 0 {
		resp, httpRes, err := apiClient.GetOwnUser(context.Background()).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		subs = []int32{resp.GetUserId()}
	}

	name := uniqueName("test-channel")
	resp, httpRes, err := apiClient.CreateChannel(context.Background()).
		Name(name).
		Description("Created by channel API tests").
		Subscribers(subs).
		Execute()
	require.NoError(t, err)
	require.NotNil(t, resp)
	requireStatusOK(t, httpRes)
	require.True(t, resp.HasId())

	return name, resp.GetId()
}

func sendStreamMessage(t *testing.T, apiClient *api.ZulipClient, streamID int32, topic, content string) int32 {
	t.Helper()

	rc := apiClient.GetZulipRC()
	require.NotNil(t, rc)
	require.NotEmpty(t, rc.Site)
	require.NotEmpty(t, rc.Email)
	require.NotEmpty(t, rc.APIKey)

	form := url.Values{}
	form.Set("type", "stream")
	form.Set("to", fmt.Sprintf("%d", streamID))
	form.Set("topic", topic)
	form.Set("content", content)

	endpoint := strings.TrimRight(rc.Site, "/") + "/api/v1/messages"
	req, err := http.NewRequestWithContext(context.Background(), http.MethodPost, endpoint, strings.NewReader(form.Encode()))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.SetBasicAuth(rc.Email, rc.APIKey)

	client := &http.Client{Timeout: 15 * time.Second}
	res, err := client.Do(req)
	require.NoError(t, err)
	defer res.Body.Close()
	require.Equal(t, http.StatusOK, res.StatusCode)

	body, err := io.ReadAll(res.Body)
	require.NoError(t, err)

	var payload struct {
		Result string `json:"result"`
		Msg    string `json:"msg"`
		Id     int32  `json:"id"`
	}
	require.NoError(t, json.Unmarshal(body, &payload))
	require.Equal(t, "success", payload.Result)
	assert.Greater(t, payload.Id, int32(0))

	return payload.Id
}

func createTopicWithMessage(t *testing.T, apiClient *api.ZulipClient, streamID int32) string {
	t.Helper()

	topic := uniqueName("topic")
	messageID := sendStreamMessage(t, apiClient, streamID, topic, fmt.Sprintf("message for %s", topic))
	assert.Greater(t, messageID, int32(0))
	return topic
}

func createChannelFolder(t *testing.T, apiClient *api.ZulipClient, name, description string) int32 {
	t.Helper()

	resp, httpRes, err := apiClient.CreateChannelFolder(context.Background()).
		Name(name).
		Description(description).
		Execute()
	require.NoError(t, err)
	require.NotNil(t, resp)
	requireStatusOK(t, httpRes)

	return resp.GetChannelFolderId()
}

func getChannelFolderIDs(t *testing.T, apiClient *api.ZulipClient) []int32 {
	t.Helper()

	resp, httpRes, err := apiClient.GetChannelFolders(context.Background()).Execute()
	require.NoError(t, err)
	require.NotNil(t, resp)
	requireStatusOK(t, httpRes)

	var ids []int32
	for _, folder := range resp.GetChannelFolders() {
		if folder.HasId() {
			ids = append(ids, folder.GetId())
		}
	}
	return ids
}

func reverseInt32Slice(values []int32) {
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		values[i], values[j] = values[j], values[i]
	}
}

func skipIfBigBlueButtonUnavailable(t *testing.T, err error) {
	t.Helper()

	var apiErr *api.GenericOpenAPIError
	if !errors.As(err, &apiErr) {
		return
	}

	message := strings.ToLower(fmt.Sprintf("%s %s", apiErr.Error(), string(apiErr.Body())))
	if strings.Contains(message, "bigbluebutton") ||
		strings.Contains(message, "not configured") ||
		strings.Contains(message, "not implemented") {
		t.Skipf("BigBlueButton not available: %s", strings.TrimSpace(string(apiErr.Body())))
	}
}

func requireStatusOK(t *testing.T, httpRes *http.Response) {
	t.Helper()
	require.NotNil(t, httpRes)
	assert.Equal(t, 200, httpRes.StatusCode)
}
