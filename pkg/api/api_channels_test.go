/*
Zulip REST API

Testing ChannelsAPIService

*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech);

package api_test

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/tum-zulip/go-zulip/pkg/api"
)

func Test_ChannelsAPIService(t *testing.T) {
	ownerClient := GetOwnerClient(t)
	ownerId := getOwnUserId(t, ownerClient)

	t.Run("AddDefaultStream", func(t *testing.T) {
		ctx := context.Background()

		_, streamId := createRandomChannel(t, ownerClient, ownerId)

		resp, httpRes, err := ownerClient.AddDefaultStream(ctx).StreamId(streamId).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
	})

	t.Run("ArchiveStream", func(t *testing.T) {
		ctx := context.Background()

		_, streamId := createRandomChannel(t, ownerClient, ownerId)

		resp, httpRes, err := ownerClient.ArchiveStream(ctx, streamId).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
	})

	t.Run("CreateChannelFolder", func(t *testing.T) {
		ctx := context.Background()

		resp, httpRes, err := ownerClient.CreateChannelFolder(ctx).
			Name(uniqueName("test-folder")).
			Description("Created during Channels API tests").
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.Greater(t, resp.ChannelFolderId, int64(0))
	})

	t.Run("DeleteTopic", func(t *testing.T) {
		ctx := context.Background()

		_, streamId := createRandomChannel(t, ownerClient, ownerId)
		topic := createTopicWithMessage(t, ownerClient, streamId)

		resp, httpRes, err := ownerClient.DeleteTopic(ctx, streamId).
			TopicName(topic).
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.True(t, resp.Complete)
	})

	t.Run("PatchChannelFolders", func(t *testing.T) {
		ctx := context.Background()

		createChannelFolder(t, ownerClient, uniqueName("patch-folder"), "first test folder")
		createChannelFolder(t, ownerClient, uniqueName("patch-folder"), "second test folder")

		originalOrder := getChannelFolderIds(t, ownerClient)
		if len(originalOrder) < 2 {
			t.Skip("need at least two channel folders to reorder")
		}

		reordered := append([]int64(nil), originalOrder...)
		reverseSlice(reordered)

		resp, httpRes, err := ownerClient.PatchChannelFolders(ctx).
			Order(reordered).
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
	})

	t.Run("RemoveDefaultStream", func(t *testing.T) {
		ctx := context.Background()

		_, streamId := createRandomChannel(t, ownerClient, ownerId)
		reqResp, _, err := ownerClient.AddDefaultStream(ctx).StreamId(streamId).Execute()
		require.NoError(t, err)
		require.NotNil(t, reqResp)

		resp, httpRes, err := ownerClient.RemoveDefaultStream(ctx).StreamId(streamId).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
	})

	t.Run("UpdateChannelFolder", func(t *testing.T) {
		ctx := context.Background()

		folderId := createChannelFolder(t, ownerClient, uniqueName("update-folder"), "initial description")

		resp, httpRes, err := ownerClient.UpdateChannelFolder(ctx, folderId).
			Description("updated folder description").
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
	})

	t.Run("UpdateStream", func(t *testing.T) {
		ctx := context.Background()

		_, streamId := createRandomChannel(t, ownerClient, ownerId)

		resp, httpRes, err := ownerClient.UpdateStream(ctx, streamId).
			Description("updated by test").
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
	})

	t.Run("CreateBigBlueButtonVideoCall", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()

		resp, httpRes, err := apiClient.CreateBigBlueButtonVideoCall(ctx).
			MeetingName(uniqueName("bbb-meeting")).
			Execute()
		if err != nil {
			skipIfBigBlueButtonUnavailable(t, err)
		}
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.NotEmpty(t, resp.Url)
	}))

	t.Run("CreateChannel", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		userId := getOwnUserId(t, apiClient)

		createRandomChannel(t, apiClient, userId)
	}))

	t.Run("GetChannelFolders", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()

		resp, httpRes, err := apiClient.GetChannelFolders(ctx).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
	}))

	t.Run("GetStreamById", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		_, streamId := createRandomChannel(t, apiClient, userId)

		resp, httpRes, err := apiClient.GetStreamById(ctx, streamId).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.Equal(t, streamId, resp.Stream.StreamId)
	}))

	t.Run("GetStreamEmailAddress", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		_, streamId := createRandomChannel(t, apiClient, userId)

		resp, httpRes, err := apiClient.GetStreamEmailAddress(ctx, streamId).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.NotEmpty(t, resp.Email)
	}))

	t.Run("GetStreamId", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		streamName, streamId := createRandomChannel(t, apiClient, userId)

		resp, httpRes, err := apiClient.GetStreamId(ctx).
			Stream(streamName).
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.Equal(t, streamId, resp.StreamId)
	}))

	t.Run("GetStreamTopics", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		_, streamId := createRandomChannel(t, apiClient, userId)
		topic := createTopicWithMessage(t, apiClient, streamId)

		resp, httpRes, err := apiClient.GetStreamTopics(ctx, streamId).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)

		found := false
		for _, entry := range resp.Topics {
			if strings.EqualFold(entry.Name, topic) {
				found = true
				break
			}
		}
		assert.True(t, found, "expected topic %q in list", topic)
	}))

	t.Run("GetStreams", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()

		resp, httpRes, err := apiClient.GetStreams(ctx).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.NotEmpty(t, resp.Streams)
	}))

	t.Run("GetSubscribers", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		_, streamId := createRandomChannel(t, apiClient, userId)

		resp, httpRes, err := apiClient.GetSubscribers(ctx, streamId).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)

		subscribers := resp.Subscribers
		assert.Contains(t, subscribers, userId)
	}))

	t.Run("GetSubscriptionStatus", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		_, streamId := createRandomChannel(t, apiClient, userId)

		resp, httpRes, err := apiClient.GetSubscriptionStatus(ctx, userId, streamId).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.True(t, resp.IsSubscribed)
	}))

	t.Run("GetSubscriptions", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()

		resp, httpRes, err := apiClient.GetSubscriptions(ctx).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.NotEmpty(t, resp.Subscriptions)
	}))

	t.Run("MuteTopic", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		_, streamId := createRandomChannel(t, apiClient, userId)
		topic := createTopicWithMessage(t, apiClient, streamId)

		resp, httpRes, err := apiClient.MuteTopic(ctx).
			StreamId(streamId).
			Topic(topic).
			Op("add").
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
	}))

	t.Run("Subscribe", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()

		desc := "Subscribed by test"
		resp, httpRes, err := apiClient.Subscribe(ctx).
			Subscriptions([]api.SubscriptionRequest{{
				Name:        uniqueName("subscribe-stream"),
				Description: &desc,
			},
			}).
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.Equal(t, "success", resp.Result)
	}))

	t.Run("Unsubscribe", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		streamName, _ := createRandomChannel(t, apiClient, userId)

		resp, httpRes, err := apiClient.Unsubscribe(ctx).
			Subscriptions([]string{streamName}).
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)

		if len(resp.Removed) > 0 {
			assert.Contains(t, resp.Removed, streamName)
		}
	}))

	t.Run("UpdateSubscriptionSettings", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		_, streamId := createRandomChannel(t, apiClient, userId)
		mute := true

		resp, httpRes, err := apiClient.UpdateSubscriptionSettings(ctx).
			SubscriptionData([]api.SubscriptionData{{
				StreamId: streamId,
				Property: api.SubscriptionPropertyIsMuted,
				Value:    api.SubscriptionDataValue{Bool: &mute},
			}}).
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
	}))

	t.Run("UpdateSubscriptions", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()

		streamName := uniqueName("update-subscriptions")
		desc := "Created in UpdateSubscriptions test"
		add := api.SubscriptionRequestWithColor{
			Name:        &streamName,
			Description: &desc,
		}

		resp, httpRes, err := apiClient.UpdateSubscriptions(ctx).
			Add([]api.SubscriptionRequestWithColor{add}).
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		assert.Equal(t, "success", resp.Result)
	}))

	t.Run("UpdateUserTopic", runForAllClients(t, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()
		userId := getOwnUserId(t, apiClient)

		_, streamId := createRandomChannel(t, apiClient, userId)
		topic := createTopicWithMessage(t, apiClient, streamId)

		resp, httpRes, err := apiClient.UpdateUserTopic(ctx).
			StreamId(streamId).
			Topic(topic).
			VisibilityPolicy(1).
			Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
	}))
}

func createRandomChannel(t *testing.T, apiClient *api.ZulipClient, subscribers ...int64) (string, int64) {
	t.Helper()

	subs := append([]int64(nil), subscribers...)
	if len(subs) == 0 {
		resp, httpRes, err := apiClient.GetOwnUser(context.Background()).Execute()
		require.NoError(t, err)
		require.NotNil(t, resp)
		requireStatusOK(t, httpRes)
		subs = []int64{resp.UserId}
	}

	name := uniqueName("test-channel")
	resp, httpRes, err := apiClient.CreateChannel(context.Background()).
		Name(name).
		Description("Created by channel API tests").
		Subscribers(subs).
		Execute()
	require.NoError(t, err)
	require.NotNil(t, resp)
	requireStatusOK(t, httpRes)

	return name, resp.Id
}

func sendStreamMessage(t *testing.T, apiClient *api.ZulipClient, streamId int64, topic, content string) int64 {
	t.Helper()

	rc := apiClient.GetZulipRC()
	require.NotNil(t, rc)
	require.NotEmpty(t, rc.Site)
	require.NotEmpty(t, rc.Email)
	require.NotEmpty(t, rc.APIKey)

	form := url.Values{}
	form.Set("type", "stream")
	form.Set("to", fmt.Sprintf("%d", streamId))
	form.Set("topic", topic)
	form.Set("content", content)

	endpoint := strings.TrimRight(rc.Site, "/") + "/api/v1/messages"
	req, err := http.NewRequestWithContext(context.Background(), http.MethodPost, endpoint, strings.NewReader(form.Encode()))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.SetBasicAuth(rc.Email, rc.APIKey)

	client := &http.Client{Timeout: 15 * time.Second}
	res, err := client.Do(req)
	require.NoError(t, err)
	defer res.Body.Close()
	require.Equal(t, http.StatusOK, res.StatusCode)

	body, err := io.ReadAll(res.Body)
	require.NoError(t, err)

	var payload struct {
		Result string `json:"result"`
		Msg    string `json:"msg"`
		Id     int64  `json:"id"`
	}
	require.NoError(t, json.Unmarshal(body, &payload))
	require.Equal(t, "success", payload.Result)
	assert.Greater(t, payload.Id, int64(0))

	return payload.Id
}

func createTopicWithMessage(t *testing.T, apiClient *api.ZulipClient, streamId int64) string {
	t.Helper()

	topic := uniqueName("topic")
	messageId := sendStreamMessage(t, apiClient, streamId, topic, fmt.Sprintf("message for %s", topic))
	assert.Greater(t, messageId, int64(0))
	return topic
}

func createChannelFolder(t *testing.T, apiClient *api.ZulipClient, name, description string) int64 {
	t.Helper()

	resp, httpRes, err := apiClient.CreateChannelFolder(context.Background()).
		Name(name).
		Description(description).
		Execute()
	require.NoError(t, err)
	require.NotNil(t, resp)
	requireStatusOK(t, httpRes)

	return resp.ChannelFolderId
}

func getChannelFolderIds(t *testing.T, apiClient *api.ZulipClient) []int64 {
	t.Helper()

	resp, httpRes, err := apiClient.GetChannelFolders(context.Background()).Execute()
	require.NoError(t, err)
	require.NotNil(t, resp)
	requireStatusOK(t, httpRes)

	var ids []int64
	for _, folder := range resp.ChannelFolders {
		ids = append(ids, folder.Id)
	}
	return ids
}

func reverseSlice(values []int64) {
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		values[i], values[j] = values[j], values[i]
	}
}

func skipIfBigBlueButtonUnavailable(t *testing.T, err error) {
	t.Helper()

	var apiErr *api.GenericOpenAPIError
	if !errors.As(err, &apiErr) {
		return
	}

	message := strings.ToLower(fmt.Sprintf("%s %s", apiErr.Error(), string(apiErr.Body())))
	if strings.Contains(message, "bigbluebutton") ||
		strings.Contains(message, "not configured") ||
		strings.Contains(message, "not implemented") {
		t.Skipf("BigBlueButton not available: %s", strings.TrimSpace(string(apiErr.Body())))
	}
}

func requireStatusOK(t *testing.T, httpRes *http.Response) {
	t.Helper()
	require.NotNil(t, httpRes)
	assert.Equal(t, 200, httpRes.StatusCode)
}
