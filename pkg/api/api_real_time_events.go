/*
Zulip REST API

Powerful open source group chat 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"

	"github.com/tum-zulip/go-zulip/pkg/models"
)


type RealTimeEventsAPI interface {

	/*
	DeleteQueue Delete an event queue

	Delete a previously registered queue.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteQueueRequest
	*/
	DeleteQueue(ctx context.Context) ApiDeleteQueueRequest

	// DeleteQueueExecute executes the request
	//  @return JsonSuccess
	DeleteQueueExecute(r ApiDeleteQueueRequest) (*models.JsonSuccess, *http.Response, error)

	/*
	GetEvents Get events from an event queue

	This endpoint allows you to receive new events from
[a registered event queue](/api/register-queue).

Long-lived clients should use the
`event_queue_longpoll_timeout_seconds` property returned by
`POST /register` as the client-side HTTP request timeout for
calls to this endpoint. It is guaranteed to be higher than
heartbeat frequency and should be respected by clients to
avoid breaking when heartbeat frequency increases.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEventsRequest
	*/
	GetEvents(ctx context.Context) ApiGetEventsRequest

	// GetEventsExecute executes the request
	//  @return GetEvents200Response
	GetEventsExecute(r ApiGetEventsRequest) (*models.GetEvents200Response, *http.Response, error)

	/*
	RealTimePost Method for RealTimePost

	(Ignored)


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRealTimePostRequest
	*/
	RealTimePost(ctx context.Context) ApiRealTimePostRequest

	// RealTimePostExecute executes the request
	RealTimePostExecute(r ApiRealTimePostRequest) (*http.Response, error)

	/*
	RegisterQueue Register an event queue

	This powerful endpoint can be used to register a Zulip "event queue"
(subscribed to certain types of "events", or updates to the messages
and other Zulip data the current user has access to), as well as to
fetch the current state of that data.

(`register` also powers the `call_on_each_event` Python API, and is
intended primarily for complex applications for which the more convenient
`call_on_each_event` API is insufficient).

This endpoint returns a `queue_id` and a `last_event_id`; these can be
used in subsequent calls to the
["events" endpoint](/api/get-events) to request events from
the Zulip server using long-polling.

The server will queue events for up to 10 minutes of inactivity.
After 10 minutes, your event queue will be garbage-collected. The
server will send `heartbeat` events every minute, which makes it easy
to implement a robust client that does not miss events unless the
client loses network connectivity with the Zulip server for 10 minutes
or longer.

Once the server garbage-collects your event queue, the server will
[return an error](/api/get-events#bad_event_queue_id-errors)
with a code of `BAD_EVENT_QUEUE_ID` if you try to fetch events from
the event queue. Your software will need to handle that error
condition by re-initializing itself (e.g. this is what triggers your
browser reloading the Zulip web app when your laptop comes back online
after being offline for more than 10 minutes).

When prototyping with this API, we recommend first calling `register`
with no `event_types` parameter to see all the available data from all
supported event types. Before using your client in production, you
should set appropriate `event_types` and `fetch_event_types` filters
so that your client only requests the data it needs. A few minutes
doing this often saves 90% of the total bandwidth and other resources
consumed by a client using this API.

See the [events system developer documentation][events-system-docs]
if you need deeper details about how the Zulip event queue system
works, avoids clients needing to worry about large classes of
potentially messy races, etc.

**Changes**: Removed `dense_mode` setting in Zulip 10.0 (feature level 364)
as we now have `web_font_size_px` and `web_line_height_percent`
settings for more control.

Before Zulip 7.0 (feature level 183), the
`realm_community_topic_editing_limit_seconds` property
was returned by the response. It was removed because it
had not been in use since the realm setting
`move_messages_within_stream_limit_seconds` was introduced
in feature level 162.

In Zulip 7.0 (feature level 163), the realm setting
`email_address_visibility` was removed. It was replaced by a [user
setting](/api/update-settings#parameter-email_address_visibility) with
a [realm user default][user-defaults], with the encoding of different
values preserved. Clients can support all versions by supporting the
current API and treating every user as having the realm's
`email_address_visibility` value.

[user-defaults]: /api/update-realm-user-settings-defaults#parameter-email_address_visibility
[events-system-docs]: https://zulip.readthedocs.io/en/latest/subsystems/events-system.html


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRegisterQueueRequest
	*/
	RegisterQueue(ctx context.Context) ApiRegisterQueueRequest

	// RegisterQueueExecute executes the request
	//  @return RegisterQueue200Response
	RegisterQueueExecute(r ApiRegisterQueueRequest) (*models.RegisterQueue200Response, *http.Response, error)

	/*
	RestErrorHandling Error handling

	Common error to many endpoints


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRestErrorHandlingRequest
	*/
	RestErrorHandling(ctx context.Context) ApiRestErrorHandlingRequest

	// RestErrorHandlingExecute executes the request
	RestErrorHandlingExecute(r ApiRestErrorHandlingRequest) (*http.Response, error)
}

type ApiDeleteQueueRequest struct {
	ctx context.Context
	ApiService RealTimeEventsAPI
	queueId *string
}

// The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). 
func (r ApiDeleteQueueRequest) QueueId(queueId string) ApiDeleteQueueRequest {
	r.queueId = &queueId
	return r
}

func (r ApiDeleteQueueRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.DeleteQueueExecute(r)
}

/*
DeleteQueue Delete an event queue

Delete a previously registered queue.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteQueueRequest
*/
func (a *APIClient) DeleteQueue(ctx context.Context) ApiDeleteQueueRequest {
	return ApiDeleteQueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JsonSuccess
func (a *APIClient) DeleteQueueExecute(r ApiDeleteQueueRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.JsonSuccess
	)

	localBasePath, err := a.cfg.ServerURLWithContext(r.ctx, "RealTimeEventsAPI.DeleteQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queueId == nil {
		return localVarReturnValue, nil, reportError("queueId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "queue_id", r.queueId, "", "")
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.BadEventQueueIdError
			err = a.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventsRequest struct {
	ctx context.Context
	ApiService RealTimeEventsAPI
	queueId *string
	lastEventId *int32
	dontBlock *bool
}

// The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). 
func (r ApiGetEventsRequest) QueueId(queueId string) ApiGetEventsRequest {
	r.queueId = &queueId
	return r
}

// The highest event ID in this queue that you&#39;ve received and wish to acknowledge. See the [code for &#x60;call_on_each_event&#x60;](https://github.com/zulip/python-zulip-api/blob/main/zulip/zulip/__init__.py) in the [zulip Python module](https://github.com/zulip/python-zulip-api) for an example implementation of correctly processing each event exactly once. 
func (r ApiGetEventsRequest) LastEventId(lastEventId int32) ApiGetEventsRequest {
	r.lastEventId = &lastEventId
	return r
}

// Set to &#x60;true&#x60; if the client is requesting a nonblocking reply. If not specified, the request will block until either a new event is available or a few minutes have passed, in which case the server will send the client a heartbeat event. 
func (r ApiGetEventsRequest) DontBlock(dontBlock bool) ApiGetEventsRequest {
	r.dontBlock = &dontBlock
	return r
}

func (r ApiGetEventsRequest) Execute() (*models.GetEvents200Response, *http.Response, error) {
	return r.ApiService.GetEventsExecute(r)
}

/*
GetEvents Get events from an event queue

This endpoint allows you to receive new events from
[a registered event queue](/api/register-queue).

Long-lived clients should use the
`event_queue_longpoll_timeout_seconds` property returned by
`POST /register` as the client-side HTTP request timeout for
calls to this endpoint. It is guaranteed to be higher than
heartbeat frequency and should be respected by clients to
avoid breaking when heartbeat frequency increases.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventsRequest
*/
func (a *APIClient) GetEvents(ctx context.Context) ApiGetEventsRequest {
	return ApiGetEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEvents200Response
func (a *APIClient) GetEventsExecute(r ApiGetEventsRequest) (*models.GetEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.GetEvents200Response
	)

	localBasePath, err := a.cfg.ServerURLWithContext(r.ctx, "RealTimeEventsAPI.GetEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queueId == nil {
		return localVarReturnValue, nil, reportError("queueId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "queue_id", r.queueId, "form", "")
	if r.lastEventId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_event_id", r.lastEventId, "form", "")
	}
	if r.dontBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dont_block", r.dontBlock, "form", "")
	} else {
		var defaultValue bool = false
		r.dontBlock = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.BadEventQueueIdError
			err = a.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRealTimePostRequest struct {
	ctx context.Context
	ApiService RealTimeEventsAPI
	eventTypes *[]string
	narrow *[][]string
	allPublicStreams *bool
}

// A JSON-encoded array indicating which types of events you&#39;re interested in. Values that you might find useful include:  - **message** (messages) - **subscription** (changes in your subscriptions) - **realm_user** (changes to users in the organization and   their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code. For most applications, one is only interested in messages, so one specifies: &#x60;\\\&quot;event_types\\\&quot;: [\\\&quot;message\\\&quot;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
func (r ApiRealTimePostRequest) EventTypes(eventTypes []string) ApiRealTimePostRequest {
	r.eventTypes = &eventTypes
	return r
}

// A JSON-encoded array of arrays of length 2 indicating the [narrow filter(s)](/api/construct-narrow) for which you&#39;d like to receive events for.  For example, to receive events for direct messages (including group direct messages) received by the user, one can use &#x60;\\\&quot;narrow\\\&quot;: [[\\\&quot;is\\\&quot;, \\\&quot;dm\\\&quot;]]&#x60;.  Unlike the API for [fetching messages](/api/get-messages), this narrow parameter is simply a filter on messages that the user receives through their channel subscriptions (or because they are a recipient of a direct message).  This means that a client that requests a &#x60;narrow&#x60; filter of &#x60;[[\\\&quot;channel\\\&quot;, \\\&quot;Denmark\\\&quot;]]&#x60; will receive events for new messages sent to that channel while the user is subscribed to that channel. The client will not receive any message events at all if the user is not subscribed to &#x60;\\\&quot;Denmark\\\&quot;&#x60;.  Newly created bot users are not usually subscribed to any channels, so bots using this API need to be [subscribed](/api/subscribe) to any channels whose messages you&#39;d like them to process using this endpoint.  See the &#x60;all_public_streams&#x60; parameter for how to process all public channel messages in an organization.  **Changes**: See [changes section](/api/construct-narrow#changes) of search/narrow filter documentation. 
func (r ApiRealTimePostRequest) Narrow(narrow [][]string) ApiRealTimePostRequest {
	r.narrow = &narrow
	return r
}

// Whether you would like to request message events from all public channels. Useful for workflow bots that you&#39;d like to see all new messages sent to public channels. (You can also subscribe the user to private channels). 
func (r ApiRealTimePostRequest) AllPublicStreams(allPublicStreams bool) ApiRealTimePostRequest {
	r.allPublicStreams = &allPublicStreams
	return r
}

func (r ApiRealTimePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.RealTimePostExecute(r)
}

/*
RealTimePost Method for RealTimePost

(Ignored)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRealTimePostRequest
*/
func (a *APIClient) RealTimePost(ctx context.Context) ApiRealTimePostRequest {
	return ApiRealTimePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *APIClient) RealTimePostExecute(r ApiRealTimePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.cfg.ServerURLWithContext(r.ctx, "RealTimeEventsAPI.RealTimePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/real-time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.eventTypes != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "event_types", r.eventTypes, "form", "multi")
	}
	if r.narrow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "narrow", r.narrow, "form", "multi")
	}
	if r.allPublicStreams != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "all_public_streams", r.allPublicStreams, "form", "")
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRegisterQueueRequest struct {
	ctx context.Context
	ApiService RealTimeEventsAPI
	applyMarkdown *bool
	clientGravatar *bool
	includeSubscribers *string
	slimPresence *bool
	presenceHistoryLimitDays *int32
	eventTypes *[]string
	allPublicStreams *bool
	clientCapabilities *map[string]interface{}
	fetchEventTypes *[]string
	narrow *[][]string
}

// Set to &#x60;true&#x60; if you would like the content to be rendered in HTML format (otherwise the API will return the raw text that the user entered) 
func (r ApiRegisterQueueRequest) ApplyMarkdown(applyMarkdown bool) ApiRegisterQueueRequest {
	r.applyMarkdown = &applyMarkdown
	return r
}

// Whether the client supports computing gravatars URLs. If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar. This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars.  The default value is &#x60;true&#x60; for authenticated requests and &#x60;false&#x60; for [unauthenticated requests](/help/public-access-option). Passing &#x60;true&#x60; in an unauthenticated request is an error.  **Changes**: Before Zulip 6.0 (feature level 149), this parameter was silently ignored and processed as though it were &#x60;false&#x60; in unauthenticated requests. 
func (r ApiRegisterQueueRequest) ClientGravatar(clientGravatar bool) ApiRegisterQueueRequest {
	r.clientGravatar = &clientGravatar
	return r
}

// Whether each returned channel object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  Client apps supporting organizations with many thousands of users should not pass &#x60;true&#x60;, because the full subscriber matrix may be several megabytes of data. The &#x60;partial&#x60; value, combined with the &#x60;subscriber_count&#x60; and fetching subscribers for individual channels as needed, is recommended to support client app features where channel subscriber data is useful.  If a client passes &#x60;partial&#x60; for this parameter, the server may, for some channels, return a subset of the channel&#39;s subscribers in the &#x60;partial_subscribers&#x60; field instead of the &#x60;subscribers&#x60; field, which always contains the complete set of subscribers.  The server guarantees that it will always return a &#x60;subscribers&#x60; field for channels with fewer than 250 total subscribers. When returning a &#x60;partial_subscribers&#x60; field, the server guarantees that all bot users and users active within the last 14 days will be included. For other cases, the server may use its discretion to determine which channels and users to include, balancing between payload size and usefulness of the data provided to the client.  Passing &#x60;true&#x60; in an [unauthenticated request](/help/public-access-option) is an error.  **Changes**: The &#x60;partial&#x60; value is new in Zulip 11.0 (feature level 412).  Before Zulip 6.0 (feature level 149), this parameter was silently ignored and processed as though it were &#x60;false&#x60; in unauthenticated requests.  New in Zulip 2.1.0. 
func (r ApiRegisterQueueRequest) IncludeSubscribers(includeSubscribers string) ApiRegisterQueueRequest {
	r.includeSubscribers = &includeSubscribers
	return r
}

// If &#x60;true&#x60;, the &#x60;presences&#x60; object returned in the response will be keyed by user ID and the entry for each user&#39;s presence data will be in the modern format.  **Changes**: New in Zulip 3.0 (no feature level; API unstable). 
func (r ApiRegisterQueueRequest) SlimPresence(slimPresence bool) ApiRegisterQueueRequest {
	r.slimPresence = &slimPresence
	return r
}

// Limits how far back in time to fetch user presence data. If not specified, defaults to 14 days. A value of N means that the oldest presence data fetched will be from at most N days ago.  **Changes**: New in Zulip 10.0 (feature level 288). 
func (r ApiRegisterQueueRequest) PresenceHistoryLimitDays(presenceHistoryLimitDays int32) ApiRegisterQueueRequest {
	r.presenceHistoryLimitDays = &presenceHistoryLimitDays
	return r
}

// A JSON-encoded array indicating which types of events you&#39;re interested in. Values that you might find useful include:  - **message** (messages) - **subscription** (changes in your subscriptions) - **realm_user** (changes to users in the organization and   their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code. For most applications, one is only interested in messages, so one specifies: &#x60;\\\&quot;event_types\\\&quot;: [\\\&quot;message\\\&quot;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
func (r ApiRegisterQueueRequest) EventTypes(eventTypes []string) ApiRegisterQueueRequest {
	r.eventTypes = &eventTypes
	return r
}

// Whether you would like to request message events from all public channels. Useful for workflow bots that you&#39;d like to see all new messages sent to public channels. (You can also subscribe the user to private channels). 
func (r ApiRegisterQueueRequest) AllPublicStreams(allPublicStreams bool) ApiRegisterQueueRequest {
	r.allPublicStreams = &allPublicStreams
	return r
}

// Dictionary containing details on features the client supports that are relevant to the format of responses sent by the server.  - &#x60;notification_settings_null&#x60;: Boolean for whether the   client can handle the current API with &#x60;null&#x60; values for   channel-level notification settings (which means the channel   is not customized and should inherit the user&#39;s global   notification settings for channel messages).   &lt;br /&gt;   **Changes**: New in Zulip 2.1.0. In earlier Zulip releases,   channel-level notification settings were simple booleans.  - &#x60;bulk_message_deletion&#x60;: Boolean for whether the client&#39;s   handler for the &#x60;delete_message&#x60; event type has been   updated to process the new bulk format (with a   &#x60;message_ids&#x60;, rather than a singleton &#x60;message_id&#x60;).   Otherwise, the server will send &#x60;delete_message&#x60; events   in a loop.   &lt;br /&gt;   **Changes**: New in Zulip 3.0 (feature level 13). This   capability is for backwards-compatibility; it will be   required in a future server release.  - &#x60;user_avatar_url_field_optional&#x60;: Boolean for whether the   client required avatar URLs for all users, or supports   using &#x60;GET /avatar/{user_id}&#x60; to access user avatars. If the   client has this capability, the server may skip sending a   &#x60;avatar_url&#x60; field in the &#x60;realm_user&#x60; at its sole discretion   to optimize network performance. This is an important optimization   in organizations with 10,000s of users.   &lt;br /&gt;   **Changes**: New in Zulip 3.0 (feature level 18).  - &#x60;stream_typing_notifications&#x60;: Boolean for whether the client   supports channel typing notifications.   &lt;br /&gt;   **Changes**: New in Zulip 4.0 (feature level 58). This capability is   for backwards-compatibility; it will be required in a   future server release.  - &#x60;user_settings_object&#x60;: Boolean for whether the client supports the modern   &#x60;user_settings&#x60; event type. If false, the server will additionally send the   legacy &#x60;update_global_notifications&#x60; and &#x60;update_display_settings&#x60; event   types.   &lt;br /&gt;   **Changes**: New in Zulip 5.0 (feature level 89). This capability is for   backwards-compatibility; it will be removed in a future server release.   Because the feature level 89 API changes were merged together, clients can   safely make a request with this client capability and also request all three   event types (&#x60;user_settings&#x60;, &#x60;update_display_settings&#x60;,   &#x60;update_global_notifications&#x60;), and get exactly one copy of settings data on   any server version. Clients can then use the &#x60;zulip_feature_level&#x60; in the   &#x60;/register&#x60; response or the presence/absence of a &#x60;user_settings&#x60; key to   determine where to look for the data.  - &#x60;linkifier_url_template&#x60;: Boolean for whether the client accepts   [linkifiers][help-linkifiers] that use [RFC 6570][rfc6570] compliant   URL templates for linkifying matches. If false or unset, then the   &#x60;realm_linkifiers&#x60; array in the &#x60;/register&#x60; response will be empty   if present, and no &#x60;realm_linkifiers&#x60; [events][events-linkifiers]   will be sent to the client.   &lt;br /&gt;   **Changes**: New in Zulip 7.0 (feature level 176). This capability   is for backwards-compatibility.  - &#x60;user_list_incomplete&#x60;: Boolean for whether the client supports not having an   incomplete user database. If true, then the &#x60;realm_users&#x60; array in the &#x60;register&#x60;   response will not include data for inaccessible users and clients of guest users will   not receive &#x60;realm_user op:add&#x60; events for newly created users that are not accessible   to the current user.   &lt;br /&gt;   **Changes**: New in Zulip 8.0 (feature level 232). This   capability is for backwards-compatibility.  - &#x60;include_deactivated_groups&#x60;: Boolean for whether the client can handle   deactivated user groups by themselves. If false, then the &#x60;realm_user_groups&#x60;   array in the &#x60;/register&#x60; response will only include active groups, clients   will receive a &#x60;remove&#x60; event instead of &#x60;update&#x60; event when a group is   deactivated and no &#x60;update&#x60; event will be sent to the client if a deactivated   user group is renamed.   &lt;br /&gt;   **Changes**: New in Zulip 10.0 (feature level 294). This   capability is for backwards-compatibility.  - &#x60;archived_channels&#x60;: Boolean for whether the client supports processing   [archived channels](/help/archive-a-channel) in the &#x60;stream&#x60; and   &#x60;subscription&#x60; event types. If &#x60;false&#x60;, the server will not include data   related to archived channels in the &#x60;register&#x60; response or in events.   &lt;br /&gt;   **Changes**: New in Zulip 10.0 (feature level 315). This allows clients to   access archived channels, without breaking backwards-compatibility for   existing clients.  - &#x60;empty_topic_name&#x60;: Boolean for whether the client supports processing   the empty string as a topic name. Clients not declaring this capability   will be sent the value of &#x60;realm_empty_topic_display_name&#x60; found in the   [POST /register](/api/register-queue) response instead of the empty string   wherever topic names appear in the register response or events involving   topic names.   &lt;br/&gt;   **Changes**: New in Zulip 10.0 (feature level 334). Previously,   the empty string was not a valid topic name.  - &#x60;simplified_presence_events&#x60;: Boolean for whether the client supports   receiving the [&#x60;presence&#x60; event type](/api/get-events#presence) with   user presence data in the modern format. If true, the server will   send these events with the &#x60;presences&#x60; field that has the user presence   data in the modern format. Otherwise, these event will contain fields   with legacy format user presence data.   &lt;br /&gt;   **Changes**: New in Zulip 11.0 (feature level 419).  [help-linkifiers]: /help/add-a-custom-linkifier [rfc6570]: https://www.rfc-editor.org/rfc/rfc6570.html [events-linkifiers]: /api/get-events#realm_linkifiers 
func (r ApiRegisterQueueRequest) ClientCapabilities(clientCapabilities map[string]interface{}) ApiRegisterQueueRequest {
	r.clientCapabilities = &clientCapabilities
	return r
}

// Same as the &#x60;event_types&#x60; parameter except that the values in &#x60;fetch_event_types&#x60; are used to fetch initial data. If &#x60;fetch_event_types&#x60; is not provided, &#x60;event_types&#x60; is used and if &#x60;event_types&#x60; is not provided, this parameter defaults to &#x60;null&#x60;.  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
func (r ApiRegisterQueueRequest) FetchEventTypes(fetchEventTypes []string) ApiRegisterQueueRequest {
	r.fetchEventTypes = &fetchEventTypes
	return r
}

// A JSON-encoded array of arrays of length 2 indicating the [narrow filter(s)](/api/construct-narrow) for which you&#39;d like to receive events for.  For example, to receive events for direct messages (including group direct messages) received by the user, one can use &#x60;\\\&quot;narrow\\\&quot;: [[\\\&quot;is\\\&quot;, \\\&quot;dm\\\&quot;]]&#x60;.  Unlike the API for [fetching messages](/api/get-messages), this narrow parameter is simply a filter on messages that the user receives through their channel subscriptions (or because they are a recipient of a direct message).  This means that a client that requests a &#x60;narrow&#x60; filter of &#x60;[[\\\&quot;channel\\\&quot;, \\\&quot;Denmark\\\&quot;]]&#x60; will receive events for new messages sent to that channel while the user is subscribed to that channel. The client will not receive any message events at all if the user is not subscribed to &#x60;\\\&quot;Denmark\\\&quot;&#x60;.  Newly created bot users are not usually subscribed to any channels, so bots using this API need to be [subscribed](/api/subscribe) to any channels whose messages you&#39;d like them to process using this endpoint.  See the &#x60;all_public_streams&#x60; parameter for how to process all public channel messages in an organization.  **Changes**: See [changes section](/api/construct-narrow#changes) of search/narrow filter documentation. 
func (r ApiRegisterQueueRequest) Narrow(narrow [][]string) ApiRegisterQueueRequest {
	r.narrow = &narrow
	return r
}

func (r ApiRegisterQueueRequest) Execute() (*models.RegisterQueue200Response, *http.Response, error) {
	return r.ApiService.RegisterQueueExecute(r)
}

/*
RegisterQueue Register an event queue

This powerful endpoint can be used to register a Zulip "event queue"
(subscribed to certain types of "events", or updates to the messages
and other Zulip data the current user has access to), as well as to
fetch the current state of that data.

(`register` also powers the `call_on_each_event` Python API, and is
intended primarily for complex applications for which the more convenient
`call_on_each_event` API is insufficient).

This endpoint returns a `queue_id` and a `last_event_id`; these can be
used in subsequent calls to the
["events" endpoint](/api/get-events) to request events from
the Zulip server using long-polling.

The server will queue events for up to 10 minutes of inactivity.
After 10 minutes, your event queue will be garbage-collected. The
server will send `heartbeat` events every minute, which makes it easy
to implement a robust client that does not miss events unless the
client loses network connectivity with the Zulip server for 10 minutes
or longer.

Once the server garbage-collects your event queue, the server will
[return an error](/api/get-events#bad_event_queue_id-errors)
with a code of `BAD_EVENT_QUEUE_ID` if you try to fetch events from
the event queue. Your software will need to handle that error
condition by re-initializing itself (e.g. this is what triggers your
browser reloading the Zulip web app when your laptop comes back online
after being offline for more than 10 minutes).

When prototyping with this API, we recommend first calling `register`
with no `event_types` parameter to see all the available data from all
supported event types. Before using your client in production, you
should set appropriate `event_types` and `fetch_event_types` filters
so that your client only requests the data it needs. A few minutes
doing this often saves 90% of the total bandwidth and other resources
consumed by a client using this API.

See the [events system developer documentation][events-system-docs]
if you need deeper details about how the Zulip event queue system
works, avoids clients needing to worry about large classes of
potentially messy races, etc.

**Changes**: Removed `dense_mode` setting in Zulip 10.0 (feature level 364)
as we now have `web_font_size_px` and `web_line_height_percent`
settings for more control.

Before Zulip 7.0 (feature level 183), the
`realm_community_topic_editing_limit_seconds` property
was returned by the response. It was removed because it
had not been in use since the realm setting
`move_messages_within_stream_limit_seconds` was introduced
in feature level 162.

In Zulip 7.0 (feature level 163), the realm setting
`email_address_visibility` was removed. It was replaced by a [user
setting](/api/update-settings#parameter-email_address_visibility) with
a [realm user default][user-defaults], with the encoding of different
values preserved. Clients can support all versions by supporting the
current API and treating every user as having the realm's
`email_address_visibility` value.

[user-defaults]: /api/update-realm-user-settings-defaults#parameter-email_address_visibility
[events-system-docs]: https://zulip.readthedocs.io/en/latest/subsystems/events-system.html


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRegisterQueueRequest
*/
func (a *APIClient) RegisterQueue(ctx context.Context) ApiRegisterQueueRequest {
	return ApiRegisterQueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterQueue200Response
func (a *APIClient) RegisterQueueExecute(r ApiRegisterQueueRequest) (*models.RegisterQueue200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *models.RegisterQueue200Response
	)

	localBasePath, err := a.cfg.ServerURLWithContext(r.ctx, "RealTimeEventsAPI.RegisterQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.applyMarkdown != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "apply_markdown", r.applyMarkdown, "form", "")
	}
	if r.clientGravatar != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "client_gravatar", r.clientGravatar, "form", "")
	}
	if r.includeSubscribers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "include_subscribers", r.includeSubscribers, "", "")
	}
	if r.slimPresence != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "slim_presence", r.slimPresence, "form", "")
	}
	if r.presenceHistoryLimitDays != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "presence_history_limit_days", r.presenceHistoryLimitDays, "", "")
	}
	if r.eventTypes != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "event_types", r.eventTypes, "form", "multi")
	}
	if r.allPublicStreams != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "all_public_streams", r.allPublicStreams, "form", "")
	}
	if r.clientCapabilities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "client_capabilities", r.clientCapabilities, "form", "")
	}
	if r.fetchEventTypes != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fetch_event_types", r.fetchEventTypes, "form", "multi")
	}
	if r.narrow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "narrow", r.narrow, "form", "multi")
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestErrorHandlingRequest struct {
	ctx context.Context
	ApiService RealTimeEventsAPI
}

func (r ApiRestErrorHandlingRequest) Execute() (*http.Response, error) {
	return r.ApiService.RestErrorHandlingExecute(r)
}

/*
RestErrorHandling Error handling

Common error to many endpoints


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestErrorHandlingRequest
*/
func (a *APIClient) RestErrorHandling(ctx context.Context) ApiRestErrorHandlingRequest {
	return ApiRestErrorHandlingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *APIClient) RestErrorHandlingExecute(r ApiRestErrorHandlingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.cfg.ServerURLWithContext(r.ctx, "RealTimeEventsAPI.RestErrorHandling")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest-error-handling"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.RestErrorHandling400Response
			err = a.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v models.RestErrorHandling401Response
			err = a.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v models.RateLimitedError
			err = a.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
