/*
Zulip REST API

Powerful open source group chat

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/tum-zulip/go-zulip/pkg/models"
)

type ChannelsAPI interface {

	/*
			AddDefaultStream Add a default channel

			Add a channel to the set of [default channels][default-channels]
		for new users joining the organization.

		[default-channels]: /help/set-default-channels-for-new-users


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiAddDefaultStreamRequest
	*/
	AddDefaultStream(ctx context.Context) ApiAddDefaultStreamRequest

	// AddDefaultStreamExecute executes the request
	//  @return models.JsonSuccess
	AddDefaultStreamExecute(r ApiAddDefaultStreamRequest) (*models.JsonSuccess, *http.Response, error)

	/*
		ArchiveStream Archive a channel

		[Archive the channel](zulip.com/help/archive-a-channel with the ID `stream_id`.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param streamId The ID of the channel to access.
		@return ApiArchiveStreamRequest
	*/
	ArchiveStream(ctx context.Context, streamId int32) ApiArchiveStreamRequest

	// ArchiveStreamExecute executes the request
	//  @return models.JsonSuccess
	ArchiveStreamExecute(r ApiArchiveStreamRequest) (*models.JsonSuccess, *http.Response, error)

	/*
			CreateBigBlueButtonVideoCall Create BigBlueButton video call

			Create a video call URL for a BigBlueButton video call.
		Requires [BigBlueButton 2.4+](/integrations/doc/big-blue-button)
		to be configured on the Zulip server.

		The acting user will be given the moderator role on the call.

		**Changes**: Prior to Zulip 10.0 (feature level 337), every
		user was given the moderator role on BigBlueButton calls, via
		encoding a moderator password in the generated URLs.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiCreateBigBlueButtonVideoCallRequest
	*/
	CreateBigBlueButtonVideoCall(ctx context.Context) ApiCreateBigBlueButtonVideoCallRequest

	// CreateBigBlueButtonVideoCallExecute executes the request
	//  @return models.CreateBigBlueButtonVideoCall200Response
	CreateBigBlueButtonVideoCallExecute(r ApiCreateBigBlueButtonVideoCallRequest) (*models.CreateBigBlueButtonVideoCall200Response, *http.Response, error)

	/*
			CreateChannel Create a channel

			Create a new [channel](zulip.com/help/create-channels and optionally
		subscribe users to the newly created channel. The initial [channel settings](zulip.com/api/update-stream
		will be determined by the optional parameters, like `invite_only`, detailed below.

		**Changes**: New in Zulip 11.0 (feature level 417). Previously, this was only possible via
		the [`POST /api/subscribe`](zulip.com/api/subscribe endpoint, which handled both creation and subscription.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiCreateChannelRequest
	*/
	CreateChannel(ctx context.Context) ApiCreateChannelRequest

	// CreateChannelExecute executes the request
	//  @return models.CreateChannel200Response
	CreateChannelExecute(r ApiCreateChannelRequest) (*models.CreateChannel200Response, *http.Response, error)

	/*
			CreateChannelFolder Create a channel folder

			Create a new channel folder, that will be used to organize
		channels in left sidebar.

		Only organization administrators can create a new channel
		folder.

		**Changes**: New in Zulip 11.0 (feature level 389).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiCreateChannelFolderRequest
	*/
	CreateChannelFolder(ctx context.Context) ApiCreateChannelFolderRequest

	// CreateChannelFolderExecute executes the request
	//  @return models.CreateChannelFolder200Response
	CreateChannelFolderExecute(r ApiCreateChannelFolderRequest) (*models.CreateChannelFolder200Response, *http.Response, error)

	/*
			DeleteTopic Delete a topic

			Delete all messages in a topic.

		Topics are a field on messages (not an independent data structure), so
		deleting all the messages in the topic deletes the topic from Zulip.

		Because this endpoint deletes messages in batches, it is possible for
		the request to time out after only deleting some messages in the topic.
		When this happens, the `complete` boolean field in the success response
		will be `false`. Clients should repeat the request when handling such a
		response. If all messages in the topic were deleted, then the success
		response will return `"complete": true`.

		**Changes**: Before Zulip 9.0 (feature level 256), the server never sent
		[`stream` op: `update`](zulip.com/api/get-events#stream-update events with an
		updated `first_message_id` for a channel when the oldest message that
		had been sent to it changed.

		Before Zulip 8.0 (feature level 211), if the server's
		processing was interrupted by a timeout, but some messages in the topic
		were deleted, then it would return `"result": "partially_completed"`,
		along with a `code` field for an error string, in the success response
		to indicate that there was a timeout and that the client should repeat
		the request.

		As of Zulip 6.0 (feature level 154), instead of returning an error
		response when a request times out after successfully deleting some of
		the messages in the topic, a success response is returned with
		`"result": "partially_completed"` to indicate that some messages were
		deleted.

		Before Zulip 6.0 (feature level 147), this request did a single atomic
		operation, which could time out for very large topics. As of this
		feature level, messages are deleted in batches, starting with the newest
		messages, so that progress is made even if the request times out and
		returns an error.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param streamId The ID of the channel to access.
			@return ApiDeleteTopicRequest
	*/
	DeleteTopic(ctx context.Context, streamId int32) ApiDeleteTopicRequest

	// DeleteTopicExecute executes the request
	//  @return models.MarkAllAsRead200Response
	DeleteTopicExecute(r ApiDeleteTopicRequest) (*models.MarkAllAsRead200Response, *http.Response, error)

	/*
			GetChannelFolders Get channel folders

			Fetches all of the channel folders in the organization.
		The folders are sorted by the `order` field.

		**Changes**: Before Zulip 11.0 (feature level 414),
		these were sorted by ID. (The `order` field didn't exist).

		New in Zulip 11.0 (feature level 389).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiGetChannelFoldersRequest
	*/
	GetChannelFolders(ctx context.Context) ApiGetChannelFoldersRequest

	// GetChannelFoldersExecute executes the request
	//  @return models.GetChannelFolders200Response
	GetChannelFoldersExecute(r ApiGetChannelFoldersRequest) (*models.GetChannelFolders200Response, *http.Response, error)

	/*
			GetStreamById Get a channel by ID

			Fetch details for the channel with the ID `stream_id`.

		**Changes**: New in Zulip 6.0 (feature level 132).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param streamId The ID of the channel to access.
			@return ApiGetStreamByIdRequest
	*/
	GetStreamById(ctx context.Context, streamId int32) ApiGetStreamByIdRequest

	// GetStreamByIdExecute executes the request
	//  @return models.GetStreamById200Response
	GetStreamByIdExecute(r ApiGetStreamByIdRequest) (*models.GetStreamById200Response, *http.Response, error)

	/*
			GetStreamEmailAddress Get channel's email address

			Get email address of a channel.

		**Changes**: New in Zulip 8.0 (feature level 226).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param streamId The ID of the channel to access.
			@return ApiGetStreamEmailAddressRequest
	*/
	GetStreamEmailAddress(ctx context.Context, streamId int32) ApiGetStreamEmailAddressRequest

	// GetStreamEmailAddressExecute executes the request
	//  @return models.GetStreamEmailAddress200Response
	GetStreamEmailAddressExecute(r ApiGetStreamEmailAddressRequest) (*models.GetStreamEmailAddress200Response, *http.Response, error)

	/*
		GetStreamId Get channel ID

		Get the unique ID of a given channel.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetStreamIdRequest
	*/
	GetStreamId(ctx context.Context) ApiGetStreamIdRequest

	// GetStreamIdExecute executes the request
	//  @return models.GetStreamId200Response
	GetStreamIdExecute(r ApiGetStreamIdRequest) (*models.GetStreamId200Response, *http.Response, error)

	/*
			GetStreamTopics Get topics in a channel

			Get all topics the user has access to in a specific channel.

		Note that for [private channels with
		protected history](zulip.com/help/channel-permissions#private-channels,
		the user will only have access to topics of messages sent after they
		[subscribed to](zulip.com/api/subscribe the channel. Similarly, a user's
		[bot](zulip.com/help/bots-overview#bot-type will only have access to messages
		sent after the bot was subscribed to the channel, instead of when the
		user subscribed.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param streamId The ID of the channel to access.
			@return ApiGetStreamTopicsRequest
	*/
	GetStreamTopics(ctx context.Context, streamId int32) ApiGetStreamTopicsRequest

	// GetStreamTopicsExecute executes the request
	//  @return models.GetStreamTopics200Response
	GetStreamTopicsExecute(r ApiGetStreamTopicsRequest) (*models.GetStreamTopics200Response, *http.Response, error)

	/*
		GetStreams Get all channels

		Get all channels that the user [has access to](zulip.com/help/channel-permissions.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetStreamsRequest
	*/
	GetStreams(ctx context.Context) ApiGetStreamsRequest

	// GetStreamsExecute executes the request
	//  @return models.GetStreams200Response
	GetStreamsExecute(r ApiGetStreamsRequest) (*models.GetStreams200Response, *http.Response, error)

	/*
		GetSubscribers Get channel subscribers

		Get all users subscribed to a channel.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param streamId The ID of the channel to access.
		@return ApiGetSubscribersRequest
	*/
	GetSubscribers(ctx context.Context, streamId int32) ApiGetSubscribersRequest

	// GetSubscribersExecute executes the request
	//  @return models.GetSubscribers200Response
	GetSubscribersExecute(r ApiGetSubscribersRequest) (*models.GetSubscribers200Response, *http.Response, error)

	/*
			GetSubscriptionStatus Get subscription status

			Check whether a user is subscribed to a channel.

		**Changes**: New in Zulip 3.0 (feature level 12).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param userId The target user's ID.
			@param streamId The ID of the channel to access.
			@return ApiGetSubscriptionStatusRequest
	*/
	GetSubscriptionStatus(ctx context.Context, userId int32, streamId int32) ApiGetSubscriptionStatusRequest

	// GetSubscriptionStatusExecute executes the request
	//  @return models.GetSubscriptionStatus200Response
	GetSubscriptionStatusExecute(r ApiGetSubscriptionStatusRequest) (*models.GetSubscriptionStatus200Response, *http.Response, error)

	/*
		GetSubscriptions Get subscribed channels

		Get all channels that the user is subscribed to.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetSubscriptionsRequest
	*/
	GetSubscriptions(ctx context.Context) ApiGetSubscriptionsRequest

	// GetSubscriptionsExecute executes the request
	//  @return models.GetSubscriptions200Response
	GetSubscriptionsExecute(r ApiGetSubscriptionsRequest) (*models.GetSubscriptions200Response, *http.Response, error)

	/*
			MuteTopic Topic muting

			[Mute or unmute a topic](zulip.com/help/mute-a-topic within a channel that
		the current user is subscribed to.

		**Changes**: Deprecated in Zulip 7.0 (feature level 170). Clients connecting
		to newer servers should use the [POST /user_topics](zulip.com/api/update-user-topic
		endpoint, as this endpoint may be removed in a future release.

		Before Zulip 7.0 (feature level 169), this endpoint
		returned an error if asked to mute a topic that was already muted
		or asked to unmute a topic that had not previously been muted.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiMuteTopicRequest

			Deprecated
	*/
	MuteTopic(ctx context.Context) ApiMuteTopicRequest

	// MuteTopicExecute executes the request
	//  @return models.JsonSuccess
	// Deprecated
	MuteTopicExecute(r ApiMuteTopicRequest) (*models.JsonSuccess, *http.Response, error)

	/*
			PatchChannelFolders Reorder channel folders

			Given an array of channel folder IDs, this method will set the `order`
		property of all of the channel folders in the organization according to
		the order of the channel folder IDs specified in the request.

		**Changes**: New in Zulip 11.0 (feature level 414).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiPatchChannelFoldersRequest
	*/
	PatchChannelFolders(ctx context.Context) ApiPatchChannelFoldersRequest

	// PatchChannelFoldersExecute executes the request
	//  @return models.JsonSuccess
	PatchChannelFoldersExecute(r ApiPatchChannelFoldersRequest) (*models.JsonSuccess, *http.Response, error)

	/*
			RemoveDefaultStream Remove a default channel

			Remove a channel from the set of [default channels][default-channels]
		for new users joining the organization.

		[default-channels]: /help/set-default-channels-for-new-users


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiRemoveDefaultStreamRequest
	*/
	RemoveDefaultStream(ctx context.Context) ApiRemoveDefaultStreamRequest

	// RemoveDefaultStreamExecute executes the request
	//  @return models.JsonSuccess
	RemoveDefaultStreamExecute(r ApiRemoveDefaultStreamRequest) (*models.JsonSuccess, *http.Response, error)

	/*
			Subscribe Subscribe to a channel

			Subscribe one or more users to one or more channels.

		If any of the specified channels do not exist, they are automatically
		created. The initial [channel settings](zulip.com/api/update-stream will be determined
		by the optional parameters, like `invite_only`, detailed below.

		Note that the ability to subscribe oneself and/or other users
		to a specified channel depends on the [channel's permissions
		settings](zulip.com/help/channel-permissions.

		**Changes**: Before Zulip 10.0 (feature level 362),
		subscriptions in archived channels could not be modified.

		Before Zulip 10.0 (feature level 357), the
		`can_subscribe_group` permission, which allows members of the
		group to subscribe themselves to the channel, did not exist.

		Before Zulip 10.0 (feature level 349), a user cannot subscribe
		other users to a private channel without being subscribed
		to that channel themselves. Now, If a user is part of
		`can_add_subscribers_group`, they can subscribe themselves or other
		users to a private channel without being subscribed to that channel.

		Removed `stream_post_policy` and `is_announcement_only`
		parameters in Zulip 10.0 (feature level 333), as permission to post
		in the channel is now controlled by `can_send_message_group`.

		Before Zulip 8.0 (feature level 208), if a user specified by the
		[`principals`][principals-param] parameter was a deactivated user,
		or did not exist, then an HTTP status code of 403 was returned with
		`code: "UNAUTHORIZED_PRINCIPAL"` in the error response. As of this
		feature level, an HTTP status code of 400 is returned with
		`code: "BAD_REQUEST"` in the error response for these cases.

		[principals-param]: /api/subscribe#parameter-principals


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiSubscribeRequest
	*/
	Subscribe(ctx context.Context) ApiSubscribeRequest

	// SubscribeExecute executes the request
	//  @return models.Subscribe200Response
	SubscribeExecute(r ApiSubscribeRequest) (*models.Subscribe200Response, *http.Response, error)

	/*
			Unsubscribe Unsubscribe from a channel

			Unsubscribe yourself or other users from one or more channels.

		In addition to managing the current user's subscriptions, this
		endpoint can be used to remove other users from channels. This
		is possible in 3 situations:

		- Organization administrators can remove any user from any
		  channel.
		- Users can remove a bot that they own from any channel that
		  the user [can access](zulip.com/help/channel-permissions.
		- Users can unsubscribe any user from a channel if they [have
		  access](zulip.com/help/channel-permissions to the channel and are a
		  member of the [user group](zulip.com/api/get-user-groups specified
		  by the [`can_remove_subscribers_group`][can-remove-parameter]
		  for the channel.

		**Changes**: Before Zulip 10.0 (feature level 362),
		subscriptions in archived channels could not be modified.

		Before Zulip 8.0 (feature level 208), if a user specified by
		the [`principals`][principals-param] parameter was a
		deactivated user, or did not exist, then an HTTP status code
		of 403 was returned with `code: "UNAUTHORIZED_PRINCIPAL"` in
		the error response. As of this feature level, an HTTP status
		code of 400 is returned with `code: "BAD_REQUEST"` in the
		error response for these cases.

		Before Zulip 8.0 (feature level 197),
		the `can_remove_subscribers_group` setting
		was named `can_remove_subscribers_group_id`.

		Before Zulip 7.0 (feature level 161), the
		`can_remove_subscribers_group_id` for all channels was always
		the system group for organization administrators.

		Before Zulip 6.0 (feature level 145), users had no special
		privileges for managing bots that they own.

		[principals-param]: /api/unsubscribe#parameter-principals
		[can-remove-parameter]: /api/subscribe#parameter-can_remove_subscribers_group


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiUnsubscribeRequest
	*/
	Unsubscribe(ctx context.Context) ApiUnsubscribeRequest

	// UnsubscribeExecute executes the request
	//  @return models.Unsubscribe200Response
	UnsubscribeExecute(r ApiUnsubscribeRequest) (*models.Unsubscribe200Response, *http.Response, error)

	/*
			UpdateChannelFolder Update a channel folder

			Update the name or description of a channel folder.

		This endpoint is also used to archive and unarchive
		a channel folder.

		Only organization administrators can update a
		channel folder.

		**Changes**: New in Zulip 11.0 (feature level 389).


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param channelFolderId The ID of the target channel folder.
			@return ApiUpdateChannelFolderRequest
	*/
	UpdateChannelFolder(ctx context.Context, channelFolderId int32) ApiUpdateChannelFolderRequest

	// UpdateChannelFolderExecute executes the request
	//  @return models.JsonSuccess
	UpdateChannelFolderExecute(r ApiUpdateChannelFolderRequest) (*models.JsonSuccess, *http.Response, error)

	/*
			UpdateStream Update a channel

			Configure the channel with the ID `stream_id`. This endpoint supports
		an organization administrator editing any property of a channel,
		including:

		- Channel [name](zulip.com/help/rename-a-channel and [description](zulip.com/help/change-the-channel-description
		- Channel [permissions](zulip.com/help/channel-permissions, including
		  [privacy](zulip.com/help/change-the-privacy-of-a-channel and [who can
		  send](zulip.com/help/channel-posting-policy.

		Note that an organization administrator's ability to change a
		[private channel's permissions](zulip.com/help/channel-permissions#private-channels
		depends on them being subscribed to the channel.

		**Changes**: Before Zulip 10.0 (feature level 362), channel privacy could not be
		edited for archived channels.

		Removed `stream_post_policy` and `is_announcement_only`
		parameters in Zulip 10.0 (feature level 333), as permission to post
		in the channel is now controlled by `can_send_message_group`.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param streamId The ID of the channel to access.
			@return ApiUpdateStreamRequest
	*/
	UpdateStream(ctx context.Context, streamId int32) ApiUpdateStreamRequest

	// UpdateStreamExecute executes the request
	//  @return models.JsonSuccess
	UpdateStreamExecute(r ApiUpdateStreamRequest) (*models.JsonSuccess, *http.Response, error)

	/*
			UpdateSubscriptionSettings Update subscription settings

			This endpoint is used to update the user's personal settings for the
		channels they are subscribed to, including muting, color, pinning, and
		per-channel notification settings.

		**Changes**: Prior to Zulip 5.0 (feature level 111), response
		object included the `subscription_data` in the
		request. The endpoint now returns the more ergonomic
		[`ignored_parameters_unsupported`][ignored-parameters] array instead.

		[ignored-parameters]: /api/rest-error-handling#ignored-parameters


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiUpdateSubscriptionSettingsRequest
	*/
	UpdateSubscriptionSettings(ctx context.Context) ApiUpdateSubscriptionSettingsRequest

	// UpdateSubscriptionSettingsExecute executes the request
	//  @return models.IgnoredParametersSuccess
	UpdateSubscriptionSettingsExecute(r ApiUpdateSubscriptionSettingsRequest) (*models.IgnoredParametersSuccess, *http.Response, error)

	/*
			UpdateSubscriptions Update subscriptions

			Update which channels you are subscribed to.

		**Changes**: Before Zulip 10.0 (feature level 362),
		subscriptions in archived channels could not be modified.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiUpdateSubscriptionsRequest
	*/
	UpdateSubscriptions(ctx context.Context) ApiUpdateSubscriptionsRequest

	// UpdateSubscriptionsExecute executes the request
	//  @return models.UpdateSubscriptions200Response
	UpdateSubscriptionsExecute(r ApiUpdateSubscriptionsRequest) (*models.UpdateSubscriptions200Response, *http.Response, error)

	/*
			UpdateUserTopic Update personal preferences for a topic

			This endpoint is used to update the personal preferences for a topic,
		such as the topic's visibility policy, which is used to implement
		[mute a topic](zulip.com/help/mute-a-topic and related features.

		This endpoint can be used to update the visibility policy for the single
		channel and topic pair indicated by the parameters for a user.

		**Changes**: New in Zulip 7.0 (feature level 170). Previously,
		toggling whether a topic was muted or unmuted was managed by the
		[PATCH /users/me/subscriptions/muted_topics](zulip.com/api/mute-topic endpoint.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiUpdateUserTopicRequest
	*/
	UpdateUserTopic(ctx context.Context) ApiUpdateUserTopicRequest

	// UpdateUserTopicExecute executes the request
	//  @return models.JsonSuccess
	UpdateUserTopicExecute(r ApiUpdateUserTopicRequest) (*models.JsonSuccess, *http.Response, error)
}

type ApiAddDefaultStreamRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	streamId   *int32
}

// The ID of the target channel.
func (r ApiAddDefaultStreamRequest) StreamId(streamId int32) ApiAddDefaultStreamRequest {
	r.streamId = &streamId
	return r
}

func (r ApiAddDefaultStreamRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.AddDefaultStreamExecute(r)
}

/*
AddDefaultStream Add a default channel

Add a channel to the set of [default channels][default-channels]
for new users joining the organization.

[default-channels]: /help/set-default-channels-for-new-users

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddDefaultStreamRequest
*/
func (c *ZulipClient) AddDefaultStream(ctx context.Context) ApiAddDefaultStreamRequest {
	return ApiAddDefaultStreamRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.JsonSuccess
func (c *ZulipClient) AddDefaultStreamExecute(r ApiAddDefaultStreamRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.JsonSuccess
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/default_streams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.streamId == nil {
		return localVarReturnValue, nil, reportError("streamId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "stream_id", r.streamId, "form", "")
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.AddDefaultStream400Response
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArchiveStreamRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	streamId   int32
}

func (r ApiArchiveStreamRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.ArchiveStreamExecute(r)
}

/*
ArchiveStream Archive a channel

[Archive the channel](zulip.com/help/archive-a-channel with the ID `stream_id`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param streamId The ID of the channel to access.
	@return ApiArchiveStreamRequest
*/
func (c *ZulipClient) ArchiveStream(ctx context.Context, streamId int32) ApiArchiveStreamRequest {
	return ApiArchiveStreamRequest{
		ApiService: c,
		ctx:        ctx,
		streamId:   streamId,
	}
}

// Execute executes the request
//
//	@return models.JsonSuccess
func (c *ZulipClient) ArchiveStreamExecute(r ApiArchiveStreamRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.JsonSuccess
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams/{stream_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", url.PathEscape(parameterValueToString(r.streamId, "streamId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.InvalidChannelError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBigBlueButtonVideoCallRequest struct {
	ctx         context.Context
	ApiService  ChannelsAPI
	meetingName *string
	voiceOnly   *bool
}

// Meeting name for the BigBlueButton video call.
func (r ApiCreateBigBlueButtonVideoCallRequest) MeetingName(meetingName string) ApiCreateBigBlueButtonVideoCallRequest {
	r.meetingName = &meetingName
	return r
}

// Configures whether the call is voice-only; if true, disables cameras for all users. Only the call creator/moderator can edit this configuration.  **Changes**: New in Zulip 10.0 (feature level 337).
func (r ApiCreateBigBlueButtonVideoCallRequest) VoiceOnly(voiceOnly bool) ApiCreateBigBlueButtonVideoCallRequest {
	r.voiceOnly = &voiceOnly
	return r
}

func (r ApiCreateBigBlueButtonVideoCallRequest) Execute() (*models.CreateBigBlueButtonVideoCall200Response, *http.Response, error) {
	return r.ApiService.CreateBigBlueButtonVideoCallExecute(r)
}

/*
CreateBigBlueButtonVideoCall Create BigBlueButton video call

Create a video call URL for a BigBlueButton video call.
Requires [BigBlueButton 2.4+](/integrations/doc/big-blue-button)
to be configured on the Zulip server.

The acting user will be given the moderator role on the call.

**Changes**: Prior to Zulip 10.0 (feature level 337), every
user was given the moderator role on BigBlueButton calls, via
encoding a moderator password in the generated URLs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateBigBlueButtonVideoCallRequest
*/
func (c *ZulipClient) CreateBigBlueButtonVideoCall(ctx context.Context) ApiCreateBigBlueButtonVideoCallRequest {
	return ApiCreateBigBlueButtonVideoCallRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.CreateBigBlueButtonVideoCall200Response
func (c *ZulipClient) CreateBigBlueButtonVideoCallExecute(r ApiCreateBigBlueButtonVideoCallRequest) (*models.CreateBigBlueButtonVideoCall200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.CreateBigBlueButtonVideoCall200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/bigbluebutton/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.meetingName == nil {
		return localVarReturnValue, nil, reportError("meetingName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "meeting_name", r.meetingName, "form", "")
	if r.voiceOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voice_only", r.voiceOnly, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateChannelRequest struct {
	ctx                               context.Context
	ApiService                        ChannelsAPI
	name                              *string
	subscribers                       *[]int32
	description                       *string
	announce                          *bool
	inviteOnly                        *bool
	isWebPublic                       *bool
	isDefaultStream                   *bool
	folderId                          *int32
	sendNewSubscriptionMessages       *bool
	topicsPolicy                      *models.TopicsPolicy
	historyPublicToSubscribers        *bool
	messageRetentionDays              *models.MessageRetentionDays
	canAddSubscribersGroup            *models.GroupSettingValue
	canDeleteAnyMessageGroup          *models.GroupSettingValue
	canDeleteOwnMessageGroup          *models.GroupSettingValue
	canRemoveSubscribersGroup         *models.GroupSettingValue
	canAdministerChannelGroup         *models.GroupSettingValue
	canMoveMessagesOutOfChannelGroup  *models.GroupSettingValue
	canMoveMessagesWithinChannelGroup *models.GroupSettingValue
	canSendMessageGroup               *models.GroupSettingValue
	canSubscribeGroup                 *models.GroupSettingValue
	canResolveTopicsGroup             *models.GroupSettingValue
}

// The name of the new channel.  Clients should use the &#x60;max_stream_name_length&#x60; returned by the [&#x60;POST /register&#x60;](zulip.com/api/register-queue endpoint to determine the maximum channel name length.
func (r ApiCreateChannelRequest) Name(name string) ApiCreateChannelRequest {
	r.name = &name
	return r
}

// A list of user IDs of the users to be subscribed to the new channel.
func (r ApiCreateChannelRequest) Subscribers(subscribers []int32) ApiCreateChannelRequest {
	r.subscribers = &subscribers
	return r
}

// The [description](zulip.com/help/change-the-channel-description to use for the new channel being created, in text/markdown format.  Clients should use the &#x60;max_stream_description_length&#x60; returned by the [&#x60;POST /register&#x60;](zulip.com/api/register-queue endpoint to determine the maximum channel description length.
func (r ApiCreateChannelRequest) Description(description string) ApiCreateChannelRequest {
	r.description = &description
	return r
}

// This determines whether [notification bot](zulip.com/help/configure-automated-notices will send an announcement about the new channel&#39;s creation.
func (r ApiCreateChannelRequest) Announce(announce bool) ApiCreateChannelRequest {
	r.announce = &announce
	return r
}

// This parameter and the ones that follow are used to request an initial configuration of the new channel.  This parameter determines whether the newly created channel will be a private channel.
func (r ApiCreateChannelRequest) InviteOnly(inviteOnly bool) ApiCreateChannelRequest {
	r.inviteOnly = &inviteOnly
	return r
}

// This parameter determines whether the newly created channel will be a web-public channel.  Note that creating web-public channels requires the &#x60;WEB_PUBLIC_STREAMS_ENABLED&#x60; [server setting][server-settings] to be enabled on the Zulip server in question, the organization to have enabled the &#x60;enable_spectator_access&#x60; realm setting, and the current user to have permission under the organization&#39;s &#x60;can_create_web_public_channel_group&#x60; realm setting.  [server-settings]: https://zulip.readthedocs.io/en/stable/production/settings.html
func (r ApiCreateChannelRequest) IsWebPublic(isWebPublic bool) ApiCreateChannelRequest {
	r.isWebPublic = &isWebPublic
	return r
}

// This parameter determines whether the newly created channel will be added as a [default channel][default-channels] for new users joining the organization.  [default-channels]: /help/set-default-channels-for-new-users
func (r ApiCreateChannelRequest) IsDefaultStream(isDefaultStream bool) ApiCreateChannelRequest {
	r.isDefaultStream = &isDefaultStream
	return r
}

// The ID of the folder to which the channel belongs.  Is &#x60;null&#x60; if channel does not belong to any folder.  **Changes**: New in Zulip 11.0 (feature level 389).
func (r ApiCreateChannelRequest) FolderId(folderId int32) ApiCreateChannelRequest {
	r.folderId = &folderId
	return r
}

// Whether any other users newly subscribed via this request should be sent a Notification Bot DM notifying them about their new subscription.  The server will never send Notification Bot DMs if more than &#x60;max_bulk_new_subscription_messages&#x60; (available in the [&#x60;POST /register&#x60;](zulip.com/api/register-queue response) users were subscribed in this request.  **Changes**: Before Zulip 11.0 (feature level 397), new subscribers were always sent a Notification Bot DM, which was unduly expensive when bulk-subscribing thousands of users to a channel.
func (r ApiCreateChannelRequest) SendNewSubscriptionMessages(sendNewSubscriptionMessages bool) ApiCreateChannelRequest {
	r.sendNewSubscriptionMessages = &sendNewSubscriptionMessages
	return r
}

func (r ApiCreateChannelRequest) TopicsPolicy(topicsPolicy models.TopicsPolicy) ApiCreateChannelRequest {
	r.topicsPolicy = &topicsPolicy
	return r
}

// Whether the channel&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the channel.  Corresponds to the shared history option for [private channels](zulip.com/help/channel-permissions#private-channels.
func (r ApiCreateChannelRequest) HistoryPublicToSubscribers(historyPublicToSubscribers bool) ApiCreateChannelRequest {
	r.historyPublicToSubscribers = &historyPublicToSubscribers
	return r
}

func (r ApiCreateChannelRequest) MessageRetentionDays(messageRetentionDays models.MessageRetentionDays) ApiCreateChannelRequest {
	r.messageRetentionDays = &messageRetentionDays
	return r
}

func (r ApiCreateChannelRequest) CanAddSubscribersGroup(canAddSubscribersGroup models.GroupSettingValue) ApiCreateChannelRequest {
	r.canAddSubscribersGroup = &canAddSubscribersGroup
	return r
}

func (r ApiCreateChannelRequest) CanDeleteAnyMessageGroup(canDeleteAnyMessageGroup models.GroupSettingValue) ApiCreateChannelRequest {
	r.canDeleteAnyMessageGroup = &canDeleteAnyMessageGroup
	return r
}

func (r ApiCreateChannelRequest) CanDeleteOwnMessageGroup(canDeleteOwnMessageGroup models.GroupSettingValue) ApiCreateChannelRequest {
	r.canDeleteOwnMessageGroup = &canDeleteOwnMessageGroup
	return r
}

func (r ApiCreateChannelRequest) CanRemoveSubscribersGroup(canRemoveSubscribersGroup models.GroupSettingValue) ApiCreateChannelRequest {
	r.canRemoveSubscribersGroup = &canRemoveSubscribersGroup
	return r
}

func (r ApiCreateChannelRequest) CanAdministerChannelGroup(canAdministerChannelGroup models.GroupSettingValue) ApiCreateChannelRequest {
	r.canAdministerChannelGroup = &canAdministerChannelGroup
	return r
}

func (r ApiCreateChannelRequest) CanMoveMessagesOutOfChannelGroup(canMoveMessagesOutOfChannelGroup models.GroupSettingValue) ApiCreateChannelRequest {
	r.canMoveMessagesOutOfChannelGroup = &canMoveMessagesOutOfChannelGroup
	return r
}

func (r ApiCreateChannelRequest) CanMoveMessagesWithinChannelGroup(canMoveMessagesWithinChannelGroup models.GroupSettingValue) ApiCreateChannelRequest {
	r.canMoveMessagesWithinChannelGroup = &canMoveMessagesWithinChannelGroup
	return r
}

func (r ApiCreateChannelRequest) CanSendMessageGroup(canSendMessageGroup models.GroupSettingValue) ApiCreateChannelRequest {
	r.canSendMessageGroup = &canSendMessageGroup
	return r
}

func (r ApiCreateChannelRequest) CanSubscribeGroup(canSubscribeGroup models.GroupSettingValue) ApiCreateChannelRequest {
	r.canSubscribeGroup = &canSubscribeGroup
	return r
}

func (r ApiCreateChannelRequest) CanResolveTopicsGroup(canResolveTopicsGroup models.GroupSettingValue) ApiCreateChannelRequest {
	r.canResolveTopicsGroup = &canResolveTopicsGroup
	return r
}

func (r ApiCreateChannelRequest) Execute() (*models.CreateChannel200Response, *http.Response, error) {
	return r.ApiService.CreateChannelExecute(r)
}

/*
CreateChannel Create a channel

Create a new [channel](zulip.com/help/create-channels and optionally
subscribe users to the newly created channel. The initial [channel settings](zulip.com/api/update-stream
will be determined by the optional parameters, like `invite_only`, detailed below.

**Changes**: New in Zulip 11.0 (feature level 417). Previously, this was only possible via
the [`POST /api/subscribe`](zulip.com/api/subscribe endpoint, which handled both creation and subscription.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateChannelRequest
*/
func (c *ZulipClient) CreateChannel(ctx context.Context) ApiCreateChannelRequest {
	return ApiCreateChannelRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.CreateChannel200Response
func (c *ZulipClient) CreateChannelExecute(r ApiCreateChannelRequest) (*models.CreateChannel200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.CreateChannel200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.subscribers == nil {
		return localVarReturnValue, nil, reportError("subscribers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	if r.subscribers != nil {
		paramJsonSubscribers, err := parameterToJson(*r.subscribers)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("subscribers", paramJsonSubscribers)
	}
	if r.announce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "announce", r.announce, "form", "")
	}
	if r.inviteOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "invite_only", r.inviteOnly, "form", "")
	}
	if r.isWebPublic != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_web_public", r.isWebPublic, "form", "")
	}
	if r.isDefaultStream != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_default_stream", r.isDefaultStream, "form", "")
	}
	if r.folderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "folder_id", r.folderId, "form", "")
	}
	if r.sendNewSubscriptionMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_new_subscription_messages", r.sendNewSubscriptionMessages, "", "")
	}
	if r.topicsPolicy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "topics_policy", r.topicsPolicy, "form", "")
	}
	if r.historyPublicToSubscribers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "history_public_to_subscribers", r.historyPublicToSubscribers, "form", "")
	}
	if r.messageRetentionDays != nil {
		paramJson, err := parameterToJson(*r.messageRetentionDays)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("message_retention_days", paramJson)
	}
	if r.canAddSubscribersGroup != nil {
		paramJson, err := parameterToJson(*r.canAddSubscribersGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_add_subscribers_group", paramJson)
	}
	if r.canDeleteAnyMessageGroup != nil {
		paramJson, err := parameterToJson(*r.canDeleteAnyMessageGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_delete_any_message_group", paramJson)
	}
	if r.canDeleteOwnMessageGroup != nil {
		paramJson, err := parameterToJson(*r.canDeleteOwnMessageGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_delete_own_message_group", paramJson)
	}
	if r.canRemoveSubscribersGroup != nil {
		paramJson, err := parameterToJson(*r.canRemoveSubscribersGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_remove_subscribers_group", paramJson)
	}
	if r.canAdministerChannelGroup != nil {
		paramJson, err := parameterToJson(*r.canAdministerChannelGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_administer_channel_group", paramJson)
	}
	if r.canMoveMessagesOutOfChannelGroup != nil {
		paramJson, err := parameterToJson(*r.canMoveMessagesOutOfChannelGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_move_messages_out_of_channel_group", paramJson)
	}
	if r.canMoveMessagesWithinChannelGroup != nil {
		paramJson, err := parameterToJson(*r.canMoveMessagesWithinChannelGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_move_messages_within_channel_group", paramJson)
	}
	if r.canSendMessageGroup != nil {
		paramJson, err := parameterToJson(*r.canSendMessageGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_send_message_group", paramJson)
	}
	if r.canSubscribeGroup != nil {
		paramJson, err := parameterToJson(*r.canSubscribeGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_subscribe_group", paramJson)
	}
	if r.canResolveTopicsGroup != nil {
		paramJson, err := parameterToJson(*r.canResolveTopicsGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_resolve_topics_group", paramJson)
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v models.CreateChannel409Response
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateChannelFolderRequest struct {
	ctx         context.Context
	ApiService  ChannelsAPI
	name        *string
	description *string
}

// The name of the channel folder.  Clients should use the &#x60;max_channel_folder_name_length&#x60; returned by the [&#x60;POST /register&#x60;](zulip.com/api/register-queue endpoint to determine the maximum channel folder name length.
func (r ApiCreateChannelFolderRequest) Name(name string) ApiCreateChannelFolderRequest {
	r.name = &name
	return r
}

// The description of the channel folder.  Clients should use the &#x60;max_channel_folder_description_length&#x60; returned by the [&#x60;POST /register&#x60;](zulip.com/api/register-queue endpoint to determine the maximum channel folder description length.
func (r ApiCreateChannelFolderRequest) Description(description string) ApiCreateChannelFolderRequest {
	r.description = &description
	return r
}

func (r ApiCreateChannelFolderRequest) Execute() (*models.CreateChannelFolder200Response, *http.Response, error) {
	return r.ApiService.CreateChannelFolderExecute(r)
}

/*
CreateChannelFolder Create a channel folder

Create a new channel folder, that will be used to organize
channels in left sidebar.

Only organization administrators can create a new channel
folder.

**Changes**: New in Zulip 11.0 (feature level 389).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateChannelFolderRequest
*/
func (c *ZulipClient) CreateChannelFolder(ctx context.Context) ApiCreateChannelFolderRequest {
	return ApiCreateChannelFolderRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.CreateChannelFolder200Response
func (c *ZulipClient) CreateChannelFolderExecute(r ApiCreateChannelFolderRequest) (*models.CreateChannelFolder200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.CreateChannelFolder200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channel_folders/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.CodedError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTopicRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	streamId   int32
	topicName  *string
}

// The name of the topic to delete.  Note: When the value of &#x60;realm_empty_topic_display_name&#x60; found in the [POST /register](zulip.com/api/register-queue response is used for this parameter, it is interpreted as an empty string.  **Changes**: Before Zulip 10.0 (feature level 334), empty string was not a valid topic name for channel messages.
func (r ApiDeleteTopicRequest) TopicName(topicName string) ApiDeleteTopicRequest {
	r.topicName = &topicName
	return r
}

func (r ApiDeleteTopicRequest) Execute() (*models.MarkAllAsRead200Response, *http.Response, error) {
	return r.ApiService.DeleteTopicExecute(r)
}

/*
DeleteTopic Delete a topic

Delete all messages in a topic.

Topics are a field on messages (not an independent data structure), so
deleting all the messages in the topic deletes the topic from Zulip.

Because this endpoint deletes messages in batches, it is possible for
the request to time out after only deleting some messages in the topic.
When this happens, the `complete` boolean field in the success response
will be `false`. Clients should repeat the request when handling such a
response. If all messages in the topic were deleted, then the success
response will return `"complete": true`.

**Changes**: Before Zulip 9.0 (feature level 256), the server never sent
[`stream` op: `update`](zulip.com/api/get-events#stream-update events with an
updated `first_message_id` for a channel when the oldest message that
had been sent to it changed.

Before Zulip 8.0 (feature level 211), if the server's
processing was interrupted by a timeout, but some messages in the topic
were deleted, then it would return `"result": "partially_completed"`,
along with a `code` field for an error string, in the success response
to indicate that there was a timeout and that the client should repeat
the request.

As of Zulip 6.0 (feature level 154), instead of returning an error
response when a request times out after successfully deleting some of
the messages in the topic, a success response is returned with
`"result": "partially_completed"` to indicate that some messages were
deleted.

Before Zulip 6.0 (feature level 147), this request did a single atomic
operation, which could time out for very large topics. As of this
feature level, messages are deleted in batches, starting with the newest
messages, so that progress is made even if the request times out and
returns an error.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param streamId The ID of the channel to access.
	@return ApiDeleteTopicRequest
*/
func (c *ZulipClient) DeleteTopic(ctx context.Context, streamId int32) ApiDeleteTopicRequest {
	return ApiDeleteTopicRequest{
		ApiService: c,
		ctx:        ctx,
		streamId:   streamId,
	}
}

// Execute executes the request
//
//	@return models.MarkAllAsRead200Response
func (c *ZulipClient) DeleteTopicExecute(r ApiDeleteTopicRequest) (*models.MarkAllAsRead200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.MarkAllAsRead200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams/{stream_id}/delete_topic"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", url.PathEscape(parameterValueToString(r.streamId, "streamId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.topicName == nil {
		return localVarReturnValue, nil, reportError("topicName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "topic_name", r.topicName, "", "")
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.CodedError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelFoldersRequest struct {
	ctx             context.Context
	ApiService      ChannelsAPI
	includeArchived *bool
}

// Whether to include archived channel folders in the response.
func (r ApiGetChannelFoldersRequest) IncludeArchived(includeArchived bool) ApiGetChannelFoldersRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiGetChannelFoldersRequest) Execute() (*models.GetChannelFolders200Response, *http.Response, error) {
	return r.ApiService.GetChannelFoldersExecute(r)
}

/*
GetChannelFolders Get channel folders

Fetches all of the channel folders in the organization.
The folders are sorted by the `order` field.

**Changes**: Before Zulip 11.0 (feature level 414),
these were sorted by ID. (The `order` field didn't exist).

New in Zulip 11.0 (feature level 389).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetChannelFoldersRequest
*/
func (c *ZulipClient) GetChannelFolders(ctx context.Context) ApiGetChannelFoldersRequest {
	return ApiGetChannelFoldersRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.GetChannelFolders200Response
func (c *ZulipClient) GetChannelFoldersExecute(r ApiGetChannelFoldersRequest) (*models.GetChannelFolders200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.GetChannelFolders200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channel_folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "include_archived", r.includeArchived, "form", "")
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStreamByIdRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	streamId   int32
}

func (r ApiGetStreamByIdRequest) Execute() (*models.GetStreamById200Response, *http.Response, error) {
	return r.ApiService.GetStreamByIdExecute(r)
}

/*
GetStreamById Get a channel by ID

Fetch details for the channel with the ID `stream_id`.

**Changes**: New in Zulip 6.0 (feature level 132).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param streamId The ID of the channel to access.
	@return ApiGetStreamByIdRequest
*/
func (c *ZulipClient) GetStreamById(ctx context.Context, streamId int32) ApiGetStreamByIdRequest {
	return ApiGetStreamByIdRequest{
		ApiService: c,
		ctx:        ctx,
		streamId:   streamId,
	}
}

// Execute executes the request
//
//	@return models.GetStreamById200Response
func (c *ZulipClient) GetStreamByIdExecute(r ApiGetStreamByIdRequest) (*models.GetStreamById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.GetStreamById200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams/{stream_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", url.PathEscape(parameterValueToString(r.streamId, "streamId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.InvalidChannelError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStreamEmailAddressRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	streamId   int32
	senderId   *int32
}

// The ID of a user or bot which should appear as the sender when messages are sent to the channel using the returned channel email address.  &#x60;sender_id&#x60; can be:  - ID of the current user. - ID of the Email gateway bot. (Default value) - ID of a bot owned by the current user.  **Changes**: New in Zulip 10.0 (feature level 335).  Previously, the sender was always Email gateway bot.
func (r ApiGetStreamEmailAddressRequest) SenderId(senderId int32) ApiGetStreamEmailAddressRequest {
	r.senderId = &senderId
	return r
}

func (r ApiGetStreamEmailAddressRequest) Execute() (*models.GetStreamEmailAddress200Response, *http.Response, error) {
	return r.ApiService.GetStreamEmailAddressExecute(r)
}

/*
GetStreamEmailAddress Get channel's email address

Get email address of a channel.

**Changes**: New in Zulip 8.0 (feature level 226).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param streamId The ID of the channel to access.
	@return ApiGetStreamEmailAddressRequest
*/
func (c *ZulipClient) GetStreamEmailAddress(ctx context.Context, streamId int32) ApiGetStreamEmailAddressRequest {
	return ApiGetStreamEmailAddressRequest{
		ApiService: c,
		ctx:        ctx,
		streamId:   streamId,
	}
}

// Execute executes the request
//
//	@return models.GetStreamEmailAddress200Response
func (c *ZulipClient) GetStreamEmailAddressExecute(r ApiGetStreamEmailAddressRequest) (*models.GetStreamEmailAddress200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.GetStreamEmailAddress200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams/{stream_id}/email_address"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", url.PathEscape(parameterValueToString(r.streamId, "streamId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.senderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sender_id", r.senderId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.InvalidChannelError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStreamIdRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	stream     *string
}

// The name of the channel to access.
func (r ApiGetStreamIdRequest) Stream(stream string) ApiGetStreamIdRequest {
	r.stream = &stream
	return r
}

func (r ApiGetStreamIdRequest) Execute() (*models.GetStreamId200Response, *http.Response, error) {
	return r.ApiService.GetStreamIdExecute(r)
}

/*
GetStreamId Get channel ID

Get the unique ID of a given channel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetStreamIdRequest
*/
func (c *ZulipClient) GetStreamId(ctx context.Context) ApiGetStreamIdRequest {
	return ApiGetStreamIdRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.GetStreamId200Response
func (c *ZulipClient) GetStreamIdExecute(r ApiGetStreamIdRequest) (*models.GetStreamId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.GetStreamId200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get_stream_id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stream == nil {
		return localVarReturnValue, nil, reportError("stream is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "stream", r.stream, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.CodedError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStreamTopicsRequest struct {
	ctx                 context.Context
	ApiService          ChannelsAPI
	streamId            int32
	allowEmptyTopicName *bool
}

// Whether the client supports processing the empty string as a topic name in the returned data.  If &#x60;false&#x60;, the value of &#x60;realm_empty_topic_display_name&#x60; found in the [&#x60;POST /register&#x60;](zulip.com/api/register-queue response is returned replacing the empty string as the topic name.  **Changes**: New in Zulip 10.0 (feature level 334). Previously, the empty string was not a valid topic.
func (r ApiGetStreamTopicsRequest) AllowEmptyTopicName(allowEmptyTopicName bool) ApiGetStreamTopicsRequest {
	r.allowEmptyTopicName = &allowEmptyTopicName
	return r
}

func (r ApiGetStreamTopicsRequest) Execute() (*models.GetStreamTopics200Response, *http.Response, error) {
	return r.ApiService.GetStreamTopicsExecute(r)
}

/*
GetStreamTopics Get topics in a channel

Get all topics the user has access to in a specific channel.

Note that for [private channels with
protected history](zulip.com/help/channel-permissions#private-channels,
the user will only have access to topics of messages sent after they
[subscribed to](zulip.com/api/subscribe the channel. Similarly, a user's
[bot](zulip.com/help/bots-overview#bot-type will only have access to messages
sent after the bot was subscribed to the channel, instead of when the
user subscribed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param streamId The ID of the channel to access.
	@return ApiGetStreamTopicsRequest
*/
func (c *ZulipClient) GetStreamTopics(ctx context.Context, streamId int32) ApiGetStreamTopicsRequest {
	return ApiGetStreamTopicsRequest{
		ApiService: c,
		ctx:        ctx,
		streamId:   streamId,
	}
}

// Execute executes the request
//
//	@return models.GetStreamTopics200Response
func (c *ZulipClient) GetStreamTopicsExecute(r ApiGetStreamTopicsRequest) (*models.GetStreamTopics200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.GetStreamTopics200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/{stream_id}/topics"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", url.PathEscape(parameterValueToString(r.streamId, "streamId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowEmptyTopicName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_empty_topic_name", r.allowEmptyTopicName, "form", "")
	} else {
		var defaultValue bool = false
		r.allowEmptyTopicName = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.InvalidChannelError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStreamsRequest struct {
	ctx                     context.Context
	ApiService              ChannelsAPI
	includePublic           *bool
	includeWebPublic        *bool
	includeSubscribed       *bool
	excludeArchived         *bool
	includeAllActive        *bool
	includeAll              *bool
	includeDefault          *bool
	includeOwnerSubscribed  *bool
	includeCanAccessContent *bool
}

// Include all public channels.
func (r ApiGetStreamsRequest) IncludePublic(includePublic bool) ApiGetStreamsRequest {
	r.includePublic = &includePublic
	return r
}

// Include all web-public channels.
func (r ApiGetStreamsRequest) IncludeWebPublic(includeWebPublic bool) ApiGetStreamsRequest {
	r.includeWebPublic = &includeWebPublic
	return r
}

// Include all channels that the user is subscribed to.
func (r ApiGetStreamsRequest) IncludeSubscribed(includeSubscribed bool) ApiGetStreamsRequest {
	r.includeSubscribed = &includeSubscribed
	return r
}

// Whether to exclude archived streams from the results.  **Changes**: New in Zulip 10.0 (feature level 315).
func (r ApiGetStreamsRequest) ExcludeArchived(excludeArchived bool) ApiGetStreamsRequest {
	r.excludeArchived = &excludeArchived
	return r
}

// Deprecated parameter to include all channels. The user must have administrative privileges to use this parameter.  **Changes**: Deprecated in Zulip 10.0 (feature level 356). Clients interacting with newer servers should use the equivalent &#x60;include_all&#x60; parameter, which does not incorrectly hint that this parameter, and not &#x60;exclude_archived&#x60;, controls whether archived channels appear in the response.
// Deprecated
func (r ApiGetStreamsRequest) IncludeAllActive(includeAllActive bool) ApiGetStreamsRequest {
	r.includeAllActive = &includeAllActive
	return r
}

// Include all channels that the user has metadata access to.  For organization administrators, this will be all channels in the organization, since organization administrators implicitly have metadata access to all channels.  **Changes**: New in Zulip 10.0 (feature level 356). On older versions, use &#x60;include_all_active&#x60;, which this replaces.
func (r ApiGetStreamsRequest) IncludeAll(includeAll bool) ApiGetStreamsRequest {
	r.includeAll = &includeAll
	return r
}

// Include all default channels for the user&#39;s realm.
func (r ApiGetStreamsRequest) IncludeDefault(includeDefault bool) ApiGetStreamsRequest {
	r.includeDefault = &includeDefault
	return r
}

// If the user is a bot, include all channels that the bot&#39;s owner is subscribed to.
func (r ApiGetStreamsRequest) IncludeOwnerSubscribed(includeOwnerSubscribed bool) ApiGetStreamsRequest {
	r.includeOwnerSubscribed = &includeOwnerSubscribed
	return r
}

// Include all the channels that the user has content access to.  **Changes**: New in Zulip 10.0 (feature level 356).
func (r ApiGetStreamsRequest) IncludeCanAccessContent(includeCanAccessContent bool) ApiGetStreamsRequest {
	r.includeCanAccessContent = &includeCanAccessContent
	return r
}

func (r ApiGetStreamsRequest) Execute() (*models.GetStreams200Response, *http.Response, error) {
	return r.ApiService.GetStreamsExecute(r)
}

/*
GetStreams Get all channels

Get all channels that the user [has access to](zulip.com/help/channel-permissions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetStreamsRequest
*/
func (c *ZulipClient) GetStreams(ctx context.Context) ApiGetStreamsRequest {
	return ApiGetStreamsRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.GetStreams200Response
func (c *ZulipClient) GetStreamsExecute(r ApiGetStreamsRequest) (*models.GetStreams200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.GetStreams200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includePublic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_public", r.includePublic, "form", "")
	} else {
		var defaultValue bool = true
		r.includePublic = &defaultValue
	}
	if r.includeWebPublic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_web_public", r.includeWebPublic, "form", "")
	} else {
		var defaultValue bool = false
		r.includeWebPublic = &defaultValue
	}
	if r.includeSubscribed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_subscribed", r.includeSubscribed, "form", "")
	} else {
		var defaultValue bool = true
		r.includeSubscribed = &defaultValue
	}
	if r.excludeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_archived", r.excludeArchived, "form", "")
	} else {
		var defaultValue bool = true
		r.excludeArchived = &defaultValue
	}
	if r.includeAllActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_all_active", r.includeAllActive, "form", "")
	} else {
		var defaultValue bool = false
		r.includeAllActive = &defaultValue
	}
	if r.includeAll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_all", r.includeAll, "form", "")
	} else {
		var defaultValue bool = false
		r.includeAll = &defaultValue
	}
	if r.includeDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_default", r.includeDefault, "form", "")
	} else {
		var defaultValue bool = false
		r.includeDefault = &defaultValue
	}
	if r.includeOwnerSubscribed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_owner_subscribed", r.includeOwnerSubscribed, "form", "")
	} else {
		var defaultValue bool = false
		r.includeOwnerSubscribed = &defaultValue
	}
	if r.includeCanAccessContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_can_access_content", r.includeCanAccessContent, "form", "")
	} else {
		var defaultValue bool = false
		r.includeCanAccessContent = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscribersRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	streamId   int32
}

func (r ApiGetSubscribersRequest) Execute() (*models.GetSubscribers200Response, *http.Response, error) {
	return r.ApiService.GetSubscribersExecute(r)
}

/*
GetSubscribers Get channel subscribers

Get all users subscribed to a channel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param streamId The ID of the channel to access.
	@return ApiGetSubscribersRequest
*/
func (c *ZulipClient) GetSubscribers(ctx context.Context, streamId int32) ApiGetSubscribersRequest {
	return ApiGetSubscribersRequest{
		ApiService: c,
		ctx:        ctx,
		streamId:   streamId,
	}
}

// Execute executes the request
//
//	@return models.GetSubscribers200Response
func (c *ZulipClient) GetSubscribersExecute(r ApiGetSubscribersRequest) (*models.GetSubscribers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.GetSubscribers200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams/{stream_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", url.PathEscape(parameterValueToString(r.streamId, "streamId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.InvalidChannelError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionStatusRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	userId     int32
	streamId   int32
}

func (r ApiGetSubscriptionStatusRequest) Execute() (*models.GetSubscriptionStatus200Response, *http.Response, error) {
	return r.ApiService.GetSubscriptionStatusExecute(r)
}

/*
GetSubscriptionStatus Get subscription status

Check whether a user is subscribed to a channel.

**Changes**: New in Zulip 3.0 (feature level 12).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId The target user's ID.
	@param streamId The ID of the channel to access.
	@return ApiGetSubscriptionStatusRequest
*/
func (c *ZulipClient) GetSubscriptionStatus(ctx context.Context, userId int32, streamId int32) ApiGetSubscriptionStatusRequest {
	return ApiGetSubscriptionStatusRequest{
		ApiService: c,
		ctx:        ctx,
		userId:     userId,
		streamId:   streamId,
	}
}

// Execute executes the request
//
//	@return models.GetSubscriptionStatus200Response
func (c *ZulipClient) GetSubscriptionStatusExecute(r ApiGetSubscriptionStatusRequest) (*models.GetSubscriptionStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.GetSubscriptionStatus200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/subscriptions/{stream_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", url.PathEscape(parameterValueToString(r.streamId, "streamId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionsRequest struct {
	ctx                context.Context
	ApiService         ChannelsAPI
	includeSubscribers *string
}

// Whether each returned channel object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  Client apps supporting organizations with many thousands of users should not pass &#x60;true&#x60;, because the full subscriber matrix may be several megabytes of data. The &#x60;partial&#x60; value, combined with the &#x60;subscriber_count&#x60; and fetching subscribers for individual channels as needed, is recommended to support client app features where channel subscriber data is useful.  If a client passes &#x60;partial&#x60; for this parameter, the server may, for some channels, return a subset of the channel&#39;s subscribers in the &#x60;partial_subscribers&#x60; field instead of the &#x60;subscribers&#x60; field, which always contains the complete set of subscribers.  The server guarantees that it will always return a &#x60;subscribers&#x60; field for channels with fewer than 250 total subscribers. When returning a &#x60;partial_subscribers&#x60; field, the server guarantees that all bot users and users active within the last 14 days will be included. For other cases, the server may use its discretion to determine which channels and users to include, balancing between payload size and usefulness of the data provided to the client.  **Changes**: The &#x60;partial&#x60; value is new in Zulip 11.0 (feature level 412).  New in Zulip 2.1.0.
func (r ApiGetSubscriptionsRequest) IncludeSubscribers(includeSubscribers string) ApiGetSubscriptionsRequest {
	r.includeSubscribers = &includeSubscribers
	return r
}

func (r ApiGetSubscriptionsRequest) Execute() (*models.GetSubscriptions200Response, *http.Response, error) {
	return r.ApiService.GetSubscriptionsExecute(r)
}

/*
GetSubscriptions Get subscribed channels

Get all channels that the user is subscribed to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSubscriptionsRequest
*/
func (c *ZulipClient) GetSubscriptions(ctx context.Context) ApiGetSubscriptionsRequest {
	return ApiGetSubscriptionsRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.GetSubscriptions200Response
func (c *ZulipClient) GetSubscriptionsExecute(r ApiGetSubscriptionsRequest) (*models.GetSubscriptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.GetSubscriptions200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeSubscribers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_subscribers", r.includeSubscribers, "form", "")
	} else {
		var defaultValue string = "false"
		r.includeSubscribers = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMuteTopicRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	topic      *string
	op         *string
	streamId   *int32
	stream     *string
}

// The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic.  Clients should use the &#x60;max_topic_length&#x60; returned by the [&#x60;POST /register&#x60;](zulip.com/api/register-queue endpoint to determine the maximum topic length.
func (r ApiMuteTopicRequest) Topic(topic string) ApiMuteTopicRequest {
	r.topic = &topic
	return r
}

// Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic.
func (r ApiMuteTopicRequest) Op(op string) ApiMuteTopicRequest {
	r.op = &op
	return r
}

// The ID of the channel to access.  Clients must provide either &#x60;stream&#x60; or &#x60;stream_id&#x60; as a parameter to this endpoint, but not both.  **Changes**: New in Zulip 2.0.0.
func (r ApiMuteTopicRequest) StreamId(streamId int32) ApiMuteTopicRequest {
	r.streamId = &streamId
	return r
}

// The name of the channel to access.  Clients must provide either &#x60;stream&#x60; or &#x60;stream_id&#x60; as a parameter to this endpoint, but not both. Clients should use &#x60;stream_id&#x60; instead of the &#x60;stream&#x60; parameter when possible.
func (r ApiMuteTopicRequest) Stream(stream string) ApiMuteTopicRequest {
	r.stream = &stream
	return r
}

func (r ApiMuteTopicRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.MuteTopicExecute(r)
}

/*
MuteTopic Topic muting

[Mute or unmute a topic](zulip.com/help/mute-a-topic within a channel that
the current user is subscribed to.

**Changes**: Deprecated in Zulip 7.0 (feature level 170). Clients connecting
to newer servers should use the [POST /user_topics](zulip.com/api/update-user-topic
endpoint, as this endpoint may be removed in a future release.

Before Zulip 7.0 (feature level 169), this endpoint
returned an error if asked to mute a topic that was already muted
or asked to unmute a topic that had not previously been muted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMuteTopicRequest

Deprecated
*/
func (c *ZulipClient) MuteTopic(ctx context.Context) ApiMuteTopicRequest {
	return ApiMuteTopicRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.JsonSuccess
//
// Deprecated
func (c *ZulipClient) MuteTopicExecute(r ApiMuteTopicRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.JsonSuccess
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions/muted_topics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.topic == nil {
		return localVarReturnValue, nil, reportError("topic is required and must be specified")
	}
	if r.op == nil {
		return localVarReturnValue, nil, reportError("op is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.streamId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stream_id", r.streamId, "form", "")
	}
	if r.stream != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stream", r.stream, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "topic", r.topic, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "op", r.op, "", "")
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchChannelFoldersRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	order      *[]int32
}

// A list of channel folder IDs representing the new order.  This list must include the IDs of all the organization&#39;s channel folders, including archived folders.
func (r ApiPatchChannelFoldersRequest) Order(order []int32) ApiPatchChannelFoldersRequest {
	r.order = &order
	return r
}

func (r ApiPatchChannelFoldersRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.PatchChannelFoldersExecute(r)
}

/*
PatchChannelFolders Reorder channel folders

Given an array of channel folder IDs, this method will set the `order`
property of all of the channel folders in the organization according to
the order of the channel folder IDs specified in the request.

**Changes**: New in Zulip 11.0 (feature level 414).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchChannelFoldersRequest
*/
func (c *ZulipClient) PatchChannelFolders(ctx context.Context) ApiPatchChannelFoldersRequest {
	return ApiPatchChannelFoldersRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.JsonSuccess
func (c *ZulipClient) PatchChannelFoldersExecute(r ApiPatchChannelFoldersRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.JsonSuccess
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channel_folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "order", r.order, "form", "multi")
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.CodedError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveDefaultStreamRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	streamId   *int32
}

// The ID of the target channel.
func (r ApiRemoveDefaultStreamRequest) StreamId(streamId int32) ApiRemoveDefaultStreamRequest {
	r.streamId = &streamId
	return r
}

func (r ApiRemoveDefaultStreamRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.RemoveDefaultStreamExecute(r)
}

/*
RemoveDefaultStream Remove a default channel

Remove a channel from the set of [default channels][default-channels]
for new users joining the organization.

[default-channels]: /help/set-default-channels-for-new-users

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRemoveDefaultStreamRequest
*/
func (c *ZulipClient) RemoveDefaultStream(ctx context.Context) ApiRemoveDefaultStreamRequest {
	return ApiRemoveDefaultStreamRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.JsonSuccess
func (c *ZulipClient) RemoveDefaultStreamExecute(r ApiRemoveDefaultStreamRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.JsonSuccess
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/default_streams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.streamId == nil {
		return localVarReturnValue, nil, reportError("streamId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "stream_id", r.streamId, "form", "")
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.InvalidChannelError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscribeRequest struct {
	ctx                               context.Context
	ApiService                        ChannelsAPI
	subscriptions                     *[]models.SubscribeRequestSubscriptionsInner
	principals                        *models.Principals
	authorizationErrorsFatal          *bool
	announce                          *bool
	inviteOnly                        *bool
	isWebPublic                       *bool
	isDefaultStream                   *bool
	historyPublicToSubscribers        *bool
	messageRetentionDays              *models.MessageRetentionDays
	topicsPolicy                      *models.TopicsPolicy
	canAddSubscribersGroup            *models.GroupSettingValue
	canRemoveSubscribersGroup         *models.GroupSettingValue
	canAdministerChannelGroup         *models.GroupSettingValue
	canDeleteAnyMessageGroup          *models.GroupSettingValue
	canDeleteOwnMessageGroup          *models.GroupSettingValue
	canMoveMessagesOutOfChannelGroup  *models.GroupSettingValue
	canMoveMessagesWithinChannelGroup *models.GroupSettingValue
	canSendMessageGroup               *models.GroupSettingValue
	canSubscribeGroup                 *models.GroupSettingValue
	canResolveTopicsGroup             *models.GroupSettingValue
	folderId                          *int32
	sendNewSubscriptionMessages       *bool
}

// A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the channel to subscribe. If the channel does not exist a new channel is created. The description of the channel created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value.
func (r ApiSubscribeRequest) Subscriptions(subscriptions []models.SubscribeRequestSubscriptionsInner) ApiSubscribeRequest {
	r.subscriptions = &subscriptions
	return r
}

func (r ApiSubscribeRequest) Principals(principals models.Principals) ApiSubscribeRequest {
	r.principals = &principals
	return r
}

// A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private channel) should be considered fatal or not. When &#x60;true&#x60;, an authorization error is reported as such. When set to &#x60;false&#x60;, the response will be a 200 and any channels where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key.
func (r ApiSubscribeRequest) AuthorizationErrorsFatal(authorizationErrorsFatal bool) ApiSubscribeRequest {
	r.authorizationErrorsFatal = &authorizationErrorsFatal
	return r
}

// If one of the channels specified did not exist previously and is thus created by this call, this determines whether [notification bot](zulip.com/help/configure-automated-notices will send an announcement about the new channel&#39;s creation.
func (r ApiSubscribeRequest) Announce(announce bool) ApiSubscribeRequest {
	r.announce = &announce
	return r
}

// As described above, this endpoint will create a new channel if passed a channel name that doesn&#39;t already exist. This parameters and the ones that follow are used to request an initial configuration of a created channel; they are ignored for channels that already exist.  This parameter determines whether any newly created channels will be private channels.
func (r ApiSubscribeRequest) InviteOnly(inviteOnly bool) ApiSubscribeRequest {
	r.inviteOnly = &inviteOnly
	return r
}

// This parameter determines whether any newly created channels will be web-public channels.  Note that creating web-public channels requires the &#x60;WEB_PUBLIC_STREAMS_ENABLED&#x60; [server setting][server-settings] to be enabled on the Zulip server in question, the organization to have enabled the &#x60;enable_spectator_access&#x60; realm setting, and the current use to have permission under the organization&#39;s &#x60;can_create_web_public_channel_group&#x60; realm setting.  [server-settings]: https://zulip.readthedocs.io/en/stable/production/settings.html  **Changes**: New in Zulip 5.0 (feature level 98).
func (r ApiSubscribeRequest) IsWebPublic(isWebPublic bool) ApiSubscribeRequest {
	r.isWebPublic = &isWebPublic
	return r
}

// This parameter determines whether any newly created channels will be added as [default channels][default-channels] for new users joining the organization.  [default-channels]: /help/set-default-channels-for-new-users  **Changes**: New in Zulip 8.0 (feature level 200). Previously, default channel status could only be changed using the [dedicated API endpoint](zulip.com/api/add-default-stream.
func (r ApiSubscribeRequest) IsDefaultStream(isDefaultStream bool) ApiSubscribeRequest {
	r.isDefaultStream = &isDefaultStream
	return r
}

// Whether the channel&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the channel.  Corresponds to the shared history option for [private channels](zulip.com/help/channel-permissions#private-channels.
func (r ApiSubscribeRequest) HistoryPublicToSubscribers(historyPublicToSubscribers bool) ApiSubscribeRequest {
	r.historyPublicToSubscribers = &historyPublicToSubscribers
	return r
}

func (r ApiSubscribeRequest) MessageRetentionDays(messageRetentionDays models.MessageRetentionDays) ApiSubscribeRequest {
	r.messageRetentionDays = &messageRetentionDays
	return r
}

func (r ApiSubscribeRequest) TopicsPolicy(topicsPolicy models.TopicsPolicy) ApiSubscribeRequest {
	r.topicsPolicy = &topicsPolicy
	return r
}

func (r ApiSubscribeRequest) CanAddSubscribersGroup(canAddSubscribersGroup models.GroupSettingValue) ApiSubscribeRequest {
	r.canAddSubscribersGroup = &canAddSubscribersGroup
	return r
}

func (r ApiSubscribeRequest) CanRemoveSubscribersGroup(canRemoveSubscribersGroup models.GroupSettingValue) ApiSubscribeRequest {
	r.canRemoveSubscribersGroup = &canRemoveSubscribersGroup
	return r
}

func (r ApiSubscribeRequest) CanAdministerChannelGroup(canAdministerChannelGroup models.GroupSettingValue) ApiSubscribeRequest {
	r.canAdministerChannelGroup = &canAdministerChannelGroup
	return r
}

func (r ApiSubscribeRequest) CanDeleteAnyMessageGroup(canDeleteAnyMessageGroup models.GroupSettingValue) ApiSubscribeRequest {
	r.canDeleteAnyMessageGroup = &canDeleteAnyMessageGroup
	return r
}

func (r ApiSubscribeRequest) CanDeleteOwnMessageGroup(canDeleteOwnMessageGroup models.GroupSettingValue) ApiSubscribeRequest {
	r.canDeleteOwnMessageGroup = &canDeleteOwnMessageGroup
	return r
}

func (r ApiSubscribeRequest) CanMoveMessagesOutOfChannelGroup(canMoveMessagesOutOfChannelGroup models.GroupSettingValue) ApiSubscribeRequest {
	r.canMoveMessagesOutOfChannelGroup = &canMoveMessagesOutOfChannelGroup
	return r
}

func (r ApiSubscribeRequest) CanMoveMessagesWithinChannelGroup(canMoveMessagesWithinChannelGroup models.GroupSettingValue) ApiSubscribeRequest {
	r.canMoveMessagesWithinChannelGroup = &canMoveMessagesWithinChannelGroup
	return r
}

func (r ApiSubscribeRequest) CanSendMessageGroup(canSendMessageGroup models.GroupSettingValue) ApiSubscribeRequest {
	r.canSendMessageGroup = &canSendMessageGroup
	return r
}

func (r ApiSubscribeRequest) CanSubscribeGroup(canSubscribeGroup models.GroupSettingValue) ApiSubscribeRequest {
	r.canSubscribeGroup = &canSubscribeGroup
	return r
}

func (r ApiSubscribeRequest) CanResolveTopicsGroup(canResolveTopicsGroup models.GroupSettingValue) ApiSubscribeRequest {
	r.canResolveTopicsGroup = &canResolveTopicsGroup
	return r
}

// This parameter determines the folder to which the newly created channel will be added.  If the value is &#x60;None&#x60;, the channel will not be added to any folder.  **Changes**: New in Zulip 11.0 (feature level 389).
func (r ApiSubscribeRequest) FolderId(folderId int32) ApiSubscribeRequest {
	r.folderId = &folderId
	return r
}

// Whether any other users newly subscribed via this request should be sent a Notification Bot DM notifying them about their new subscription.  The server will never send Notification Bot DMs if more than &#x60;max_bulk_new_subscription_messages&#x60; (available in the [&#x60;POST /register&#x60;](zulip.com/api/register-queue response) users were subscribed in this request.  **Changes**: Before Zulip 11.0 (feature level 397), new subscribers were always sent a Notification Bot DM, which was unduly expensive when bulk-subscribing thousands of users to a channel.
func (r ApiSubscribeRequest) SendNewSubscriptionMessages(sendNewSubscriptionMessages bool) ApiSubscribeRequest {
	r.sendNewSubscriptionMessages = &sendNewSubscriptionMessages
	return r
}

func (r ApiSubscribeRequest) Execute() (*models.Subscribe200Response, *http.Response, error) {
	return r.ApiService.SubscribeExecute(r)
}

/*
Subscribe Subscribe to a channel

Subscribe one or more users to one or more channels.

If any of the specified channels do not exist, they are automatically
created. The initial [channel settings](zulip.com/api/update-stream will be determined
by the optional parameters, like `invite_only`, detailed below.

Note that the ability to subscribe oneself and/or other users
to a specified channel depends on the [channel's permissions
settings](zulip.com/help/channel-permissions.

**Changes**: Before Zulip 10.0 (feature level 362),
subscriptions in archived channels could not be modified.

Before Zulip 10.0 (feature level 357), the
`can_subscribe_group` permission, which allows members of the
group to subscribe themselves to the channel, did not exist.

Before Zulip 10.0 (feature level 349), a user cannot subscribe
other users to a private channel without being subscribed
to that channel themselves. Now, If a user is part of
`can_add_subscribers_group`, they can subscribe themselves or other
users to a private channel without being subscribed to that channel.

Removed `stream_post_policy` and `is_announcement_only`
parameters in Zulip 10.0 (feature level 333), as permission to post
in the channel is now controlled by `can_send_message_group`.

Before Zulip 8.0 (feature level 208), if a user specified by the
[`principals`][principals-param] parameter was a deactivated user,
or did not exist, then an HTTP status code of 403 was returned with
`code: "UNAUTHORIZED_PRINCIPAL"` in the error response. As of this
feature level, an HTTP status code of 400 is returned with
`code: "BAD_REQUEST"` in the error response for these cases.

[principals-param]: /api/subscribe#parameter-principals

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSubscribeRequest
*/
func (c *ZulipClient) Subscribe(ctx context.Context) ApiSubscribeRequest {
	return ApiSubscribeRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.Subscribe200Response
func (c *ZulipClient) SubscribeExecute(r ApiSubscribeRequest) (*models.Subscribe200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.Subscribe200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptions == nil {
		return localVarReturnValue, nil, reportError("subscriptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subscriptions", r.subscriptions, "form", "multi")
	if r.principals != nil {
		paramJson, err := parameterToJson(*r.principals)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("principals", paramJson)
	}
	if r.authorizationErrorsFatal != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "authorization_errors_fatal", r.authorizationErrorsFatal, "form", "")
	}
	if r.announce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "announce", r.announce, "form", "")
	}
	if r.inviteOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "invite_only", r.inviteOnly, "form", "")
	}
	if r.isWebPublic != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_web_public", r.isWebPublic, "form", "")
	}
	if r.isDefaultStream != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_default_stream", r.isDefaultStream, "form", "")
	}
	if r.historyPublicToSubscribers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "history_public_to_subscribers", r.historyPublicToSubscribers, "form", "")
	}
	if r.messageRetentionDays != nil {
		paramJson, err := parameterToJson(*r.messageRetentionDays)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("message_retention_days", paramJson)
	}
	if r.topicsPolicy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "topics_policy", r.topicsPolicy, "form", "")
	}
	if r.canAddSubscribersGroup != nil {
		paramJson, err := parameterToJson(*r.canAddSubscribersGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_add_subscribers_group", paramJson)
	}
	if r.canRemoveSubscribersGroup != nil {
		paramJson, err := parameterToJson(*r.canRemoveSubscribersGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_remove_subscribers_group", paramJson)
	}
	if r.canAdministerChannelGroup != nil {
		paramJson, err := parameterToJson(*r.canAdministerChannelGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_administer_channel_group", paramJson)
	}
	if r.canDeleteAnyMessageGroup != nil {
		paramJson, err := parameterToJson(*r.canDeleteAnyMessageGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_delete_any_message_group", paramJson)
	}
	if r.canDeleteOwnMessageGroup != nil {
		paramJson, err := parameterToJson(*r.canDeleteOwnMessageGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_delete_own_message_group", paramJson)
	}
	if r.canMoveMessagesOutOfChannelGroup != nil {
		paramJson, err := parameterToJson(*r.canMoveMessagesOutOfChannelGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_move_messages_out_of_channel_group", paramJson)
	}
	if r.canMoveMessagesWithinChannelGroup != nil {
		paramJson, err := parameterToJson(*r.canMoveMessagesWithinChannelGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_move_messages_within_channel_group", paramJson)
	}
	if r.canSendMessageGroup != nil {
		paramJson, err := parameterToJson(*r.canSendMessageGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_send_message_group", paramJson)
	}
	if r.canSubscribeGroup != nil {
		paramJson, err := parameterToJson(*r.canSubscribeGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_subscribe_group", paramJson)
	}
	if r.canResolveTopicsGroup != nil {
		paramJson, err := parameterToJson(*r.canResolveTopicsGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_resolve_topics_group", paramJson)
	}
	if r.folderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "folder_id", r.folderId, "form", "")
	}
	if r.sendNewSubscriptionMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_new_subscription_messages", r.sendNewSubscriptionMessages, "", "")
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.CodedError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsubscribeRequest struct {
	ctx           context.Context
	ApiService    ChannelsAPI
	subscriptions *[]string
	principals    *models.Principals
}

// A list of channel names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API.
func (r ApiUnsubscribeRequest) Subscriptions(subscriptions []string) ApiUnsubscribeRequest {
	r.subscriptions = &subscriptions
	return r
}

func (r ApiUnsubscribeRequest) Principals(principals models.Principals) ApiUnsubscribeRequest {
	r.principals = &principals
	return r
}

func (r ApiUnsubscribeRequest) Execute() (*models.Unsubscribe200Response, *http.Response, error) {
	return r.ApiService.UnsubscribeExecute(r)
}

/*
Unsubscribe Unsubscribe from a channel

Unsubscribe yourself or other users from one or more channels.

In addition to managing the current user's subscriptions, this
endpoint can be used to remove other users from channels. This
is possible in 3 situations:

  - Organization administrators can remove any user from any
    channel.
  - Users can remove a bot that they own from any channel that
    the user [can access](zulip.com/help/channel-permissions.
  - Users can unsubscribe any user from a channel if they [have
    access](zulip.com/help/channel-permissions to the channel and are a
    member of the [user group](zulip.com/api/get-user-groups specified
    by the [`can_remove_subscribers_group`][can-remove-parameter]
    for the channel.

**Changes**: Before Zulip 10.0 (feature level 362),
subscriptions in archived channels could not be modified.

Before Zulip 8.0 (feature level 208), if a user specified by
the [`principals`][principals-param] parameter was a
deactivated user, or did not exist, then an HTTP status code
of 403 was returned with `code: "UNAUTHORIZED_PRINCIPAL"` in
the error response. As of this feature level, an HTTP status
code of 400 is returned with `code: "BAD_REQUEST"` in the
error response for these cases.

Before Zulip 8.0 (feature level 197),
the `can_remove_subscribers_group` setting
was named `can_remove_subscribers_group_id`.

Before Zulip 7.0 (feature level 161), the
`can_remove_subscribers_group_id` for all channels was always
the system group for organization administrators.

Before Zulip 6.0 (feature level 145), users had no special
privileges for managing bots that they own.

[principals-param]: /api/unsubscribe#parameter-principals
[can-remove-parameter]: /api/subscribe#parameter-can_remove_subscribers_group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUnsubscribeRequest
*/
func (c *ZulipClient) Unsubscribe(ctx context.Context) ApiUnsubscribeRequest {
	return ApiUnsubscribeRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.Unsubscribe200Response
func (c *ZulipClient) UnsubscribeExecute(r ApiUnsubscribeRequest) (*models.Unsubscribe200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.Unsubscribe200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptions == nil {
		return localVarReturnValue, nil, reportError("subscriptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subscriptions", r.subscriptions, "form", "multi")
	if r.principals != nil {
		paramJson, err := parameterToJson(*r.principals)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("principals", paramJson)
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.NonExistingChannelNameError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateChannelFolderRequest struct {
	ctx             context.Context
	ApiService      ChannelsAPI
	channelFolderId int32
	name            *string
	description     *string
	isArchived      *bool
}

// The new name of the channel folder.  Clients should use the &#x60;max_channel_folder_name_length&#x60; returned by the [&#x60;POST /register&#x60;](zulip.com/api/register-queue endpoint to determine the maximum channel folder name length.
func (r ApiUpdateChannelFolderRequest) Name(name string) ApiUpdateChannelFolderRequest {
	r.name = &name
	return r
}

// The new description of the channel folder.  Clients should use the &#x60;max_channel_folder_description_length&#x60; returned by the [&#x60;POST /register&#x60;](zulip.com/api/register-queue endpoint to determine the maximum channel folder description length.
func (r ApiUpdateChannelFolderRequest) Description(description string) ApiUpdateChannelFolderRequest {
	r.description = &description
	return r
}

// Whether to archive or unarchive the channel folder.
func (r ApiUpdateChannelFolderRequest) IsArchived(isArchived bool) ApiUpdateChannelFolderRequest {
	r.isArchived = &isArchived
	return r
}

func (r ApiUpdateChannelFolderRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.UpdateChannelFolderExecute(r)
}

/*
UpdateChannelFolder Update a channel folder

Update the name or description of a channel folder.

This endpoint is also used to archive and unarchive
a channel folder.

Only organization administrators can update a
channel folder.

**Changes**: New in Zulip 11.0 (feature level 389).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelFolderId The ID of the target channel folder.
	@return ApiUpdateChannelFolderRequest
*/
func (c *ZulipClient) UpdateChannelFolder(ctx context.Context, channelFolderId int32) ApiUpdateChannelFolderRequest {
	return ApiUpdateChannelFolderRequest{
		ApiService:      c,
		ctx:             ctx,
		channelFolderId: channelFolderId,
	}
}

// Execute executes the request
//
//	@return models.JsonSuccess
func (c *ZulipClient) UpdateChannelFolderExecute(r ApiUpdateChannelFolderRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.JsonSuccess
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channel_folders/{channel_folder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"channel_folder_id"+"}", url.PathEscape(parameterValueToString(r.channelFolderId, "channelFolderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	if r.isArchived != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_archived", r.isArchived, "", "")
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.CodedError
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateStreamRequest struct {
	ctx                               context.Context
	ApiService                        ChannelsAPI
	streamId                          int32
	description                       *string
	newName                           *string
	isPrivate                         *bool
	isWebPublic                       *bool
	historyPublicToSubscribers        *bool
	isDefaultStream                   *bool
	messageRetentionDays              *models.MessageRetentionDays
	isArchived                        *bool
	folderId                          *int32
	topicsPolicy                      *models.TopicsPolicy
	canAddSubscribersGroup            *models.GroupSettingValueUpdate
	canRemoveSubscribersGroup         *models.GroupSettingValueUpdate
	canAdministerChannelGroup         *models.GroupSettingValueUpdate
	canDeleteAnyMessageGroup          *models.GroupSettingValueUpdate
	canDeleteOwnMessageGroup          *models.GroupSettingValueUpdate
	canMoveMessagesOutOfChannelGroup  *models.GroupSettingValueUpdate
	canMoveMessagesWithinChannelGroup *models.GroupSettingValueUpdate
	canSendMessageGroup               *models.GroupSettingValueUpdate
	canSubscribeGroup                 *models.GroupSettingValueUpdate
	canResolveTopicsGroup             *models.GroupSettingValueUpdate
}

// The new [description](zulip.com/help/change-the-channel-description for the channel, in [Zulip-flavored Markdown](zulip.com/help/format-your-message-using-markdown format.  Clients should use the &#x60;max_stream_description_length&#x60; returned by the [&#x60;POST /register&#x60;](zulip.com/api/register-queue endpoint to determine the maximum channel description length.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).
func (r ApiUpdateStreamRequest) Description(description string) ApiUpdateStreamRequest {
	r.description = &description
	return r
}

// The new name for the channel.  Clients should use the &#x60;max_stream_name_length&#x60; returned by the [&#x60;POST /register&#x60;](zulip.com/api/register-queue endpoint to determine the maximum channel name length.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).
func (r ApiUpdateStreamRequest) NewName(newName string) ApiUpdateStreamRequest {
	r.newName = &newName
	return r
}

// Change whether the channel is a private channel.
func (r ApiUpdateStreamRequest) IsPrivate(isPrivate bool) ApiUpdateStreamRequest {
	r.isPrivate = &isPrivate
	return r
}

// Change whether the channel is a web-public channel.  Note that creating web-public channels requires the &#x60;WEB_PUBLIC_STREAMS_ENABLED&#x60; [server setting][server-settings] to be enabled on the Zulip server in question, the organization to have enabled the &#x60;enable_spectator_access&#x60; realm setting, and the current use to have permission under the organization&#39;s &#x60;can_create_web_public_channel_group&#x60; realm setting.  [server-settings]: https://zulip.readthedocs.io/en/stable/production/settings.html  **Changes**: New in Zulip 5.0 (feature level 98).
func (r ApiUpdateStreamRequest) IsWebPublic(isWebPublic bool) ApiUpdateStreamRequest {
	r.isWebPublic = &isWebPublic
	return r
}

// Whether the channel&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the channel.  Corresponds to the shared history option for [private channels](zulip.com/help/channel-permissions#private-channels.  It&#39;s an error for this parameter to be false for a public or web-public channel and when is_private is false.  **Changes**: Before Zulip 6.0 (feature level 136), &#x60;history_public_to_subscribers&#x60; was silently ignored unless the request also contained either &#x60;is_private&#x60; or &#x60;is_web_public&#x60;.
func (r ApiUpdateStreamRequest) HistoryPublicToSubscribers(historyPublicToSubscribers bool) ApiUpdateStreamRequest {
	r.historyPublicToSubscribers = &historyPublicToSubscribers
	return r
}

// Add or remove the channel as a [default channel][default-channel] for new users joining the organization.  [default-channel]: /help/set-default-channels-for-new-users  **Changes**: New in Zulip 8.0 (feature level 200). Previously, default channel status could only be changed using the [dedicated API endpoint](zulip.com/api/add-default-stream.
func (r ApiUpdateStreamRequest) IsDefaultStream(isDefaultStream bool) ApiUpdateStreamRequest {
	r.isDefaultStream = &isDefaultStream
	return r
}

func (r ApiUpdateStreamRequest) MessageRetentionDays(messageRetentionDays models.MessageRetentionDays) ApiUpdateStreamRequest {
	r.messageRetentionDays = &messageRetentionDays
	return r
}

// A boolean indicating whether the channel is [archived](zulip.com/help/archive-a-channel or unarchived. Currently only allows unarchiving previously archived channels.  **Changes**: New in Zulip 11.0 (feature level 388).
func (r ApiUpdateStreamRequest) IsArchived(isArchived bool) ApiUpdateStreamRequest {
	r.isArchived = &isArchived
	return r
}

// ID of the new folder to which the channel should belong.  It can be &#x60;None&#x60; if the user wants to just remove the channel from its existing folder.  **Changes**: New in Zulip 11.0 (feature level 389).
func (r ApiUpdateStreamRequest) FolderId(folderId int32) ApiUpdateStreamRequest {
	r.folderId = &folderId
	return r
}

func (r ApiUpdateStreamRequest) TopicsPolicy(topicsPolicy models.TopicsPolicy) ApiUpdateStreamRequest {
	r.topicsPolicy = &topicsPolicy
	return r
}

// The set of users who have permission to add subscribers to this channel expressed as an [update to a group-setting value][update-group-setting].  [update-group-setting]: /api/group-setting-values#updating-group-setting-values  Users who can administer the channel or have similar realm-level permissions can add subscribers to a public channel regardless of the value of this setting.  Users in this group need not be subscribed to a private channel to add subscribers to it.  Note that a user must [have content access](zulip.com/help/channel-permissions to a channel and permission to administer the channel in order to modify this setting.  **Changes**: New in Zulip 10.0 (feature level 342). Previously, there was no channel-level setting for this permission.
func (r ApiUpdateStreamRequest) CanAddSubscribersGroup(canAddSubscribersGroup models.GroupSettingValueUpdate) ApiUpdateStreamRequest {
	r.canAddSubscribersGroup = &canAddSubscribersGroup
	return r
}

// The set of users who have permission to unsubscribe others from this channel expressed as an [update to a group-setting value][update-group-setting].  [update-group-setting]: /api/group-setting-values#updating-group-setting-values  Organization administrators can unsubscribe others from a channel as though they were in this group without being explicitly listed here.  Note that a user must have metadata access to a channel and permission to administer the channel in order to modify this setting.  **Changes**: Prior to Zulip 10.0 (feature level 349), channel administrators could not unsubscribe other users if they were not an organization administrator or part of &#x60;can_remove_subscribers_group&#x60;. Realm administrators were not allowed to unsubscribe other users from a private channel if they were not subscribed to that channel.  Prior to Zulip 10.0 (feature level 320), this value was always the integer ID of a system group.  Before Zulip 8.0 (feature level 197), the &#x60;can_remove_subscribers_group&#x60; setting was named &#x60;can_remove_subscribers_group_id&#x60;.  New in Zulip 7.0 (feature level 161).
func (r ApiUpdateStreamRequest) CanRemoveSubscribersGroup(canRemoveSubscribersGroup models.GroupSettingValueUpdate) ApiUpdateStreamRequest {
	r.canRemoveSubscribersGroup = &canRemoveSubscribersGroup
	return r
}

// The set of users who have permission to administer this channel expressed as an [update to a group-setting value][update-group-setting].  [update-group-setting]: /api/group-setting-values#updating-group-setting-values  Organization administrators can administer every channel as though they were in this group without being explicitly listed here.  Note that a user must [have content access](zulip.com/help/channel-permissions to a channel in order to add other subscribers to the channel.  **Changes**: Prior to Zulip 10.0 (feature level 349) a user needed to [have content access](zulip.com/help/channel-permissions to a channel in order to modify it. The exception to this rule was that organization administrators can edit channel names and descriptions without having full access to the channel.  New in Zulip 10.0 (feature level 325). Prior to this change, the permission to administer channels was limited to realm administrators.
func (r ApiUpdateStreamRequest) CanAdministerChannelGroup(canAdministerChannelGroup models.GroupSettingValueUpdate) ApiUpdateStreamRequest {
	r.canAdministerChannelGroup = &canAdministerChannelGroup
	return r
}

// The set of users who have permission to delete any message in the channel expressed as an [update to a group-setting value][update-group-setting].  [update-group-setting]: /api/group-setting-values#updating-group-setting-values  Note that a user must [have content access](zulip.com/help/channel-permissions to a channel in order to delete any message in the channel.  Users present in the organization-level &#x60;can_delete_any_message_group&#x60; setting can always delete any message in the channel if they [have content access](zulip.com/help/channel-permissions to that channel.  **Changes**: New in Zulip 11.0 (feature level 407). Prior to this change, only the users in &#x60;can_delete_any_message_group&#x60; were able delete any message in the organization.
func (r ApiUpdateStreamRequest) CanDeleteAnyMessageGroup(canDeleteAnyMessageGroup models.GroupSettingValueUpdate) ApiUpdateStreamRequest {
	r.canDeleteAnyMessageGroup = &canDeleteAnyMessageGroup
	return r
}

// The set of users who have permission to delete the messages that they have sent in the channel expressed as an [update to a group-setting value][update-group-setting].  [update-group-setting]: /api/group-setting-values#updating-group-setting-values  Note that a user must [have content access](zulip.com/help/channel-permissions to a channel in order to delete their own message in the channel.  Users with permission to delete any message in the channel and users present in the organization-level &#x60;can_delete_own_message_group&#x60; setting can always delete their own messages in the channel if they [have content access](zulip.com/help/channel-permissions to that channel.  **Changes**: New in Zulip 11.0 (feature level 407). Prior to this change, only the users in the organization-level &#x60;can_delete_any_message_group&#x60; and &#x60;can_delete_own_message_group&#x60; settings were able delete their own messages in the organization.
func (r ApiUpdateStreamRequest) CanDeleteOwnMessageGroup(canDeleteOwnMessageGroup models.GroupSettingValueUpdate) ApiUpdateStreamRequest {
	r.canDeleteOwnMessageGroup = &canDeleteOwnMessageGroup
	return r
}

// The set of users who have permission to move messages out of this channel expressed as an [update to a group-setting value][update-group-setting].  [update-group-setting]: /api/group-setting-values#updating-group-setting-values  Note that a user must [have content access](zulip.com/help/channel-permissions to a channel in order to move messages out of the channel.  Channel administrators and users present in the organization-level &#x60;can_move_messages_between_channels_group&#x60; setting can always move messages out of the channel if they [have content access](zulip.com/help/channel-permissions to the channel.  **Changes**: New in Zulip 11.0 (feature level 396). Prior to this change, only the users in &#x60;can_move_messages_between_channels_group&#x60; were able move messages between channels.
func (r ApiUpdateStreamRequest) CanMoveMessagesOutOfChannelGroup(canMoveMessagesOutOfChannelGroup models.GroupSettingValueUpdate) ApiUpdateStreamRequest {
	r.canMoveMessagesOutOfChannelGroup = &canMoveMessagesOutOfChannelGroup
	return r
}

// The set of users who have permission to move messages within this channel expressed as an [update to a group-setting value][update-group-setting].  [update-group-setting]: /api/group-setting-values#updating-group-setting-values  Note that a user must [have content access](zulip.com/help/channel-permissions to a channel in order to move messages within the channel.  Channel administrators and users present in the organization-level &#x60;can_move_messages_between_topics_group&#x60; setting can always move messages within the channel if they [have content access](zulip.com/help/channel-permissions to the channel.  **Changes**: New in Zulip 11.0 (feature level 396). Prior to this change, only the users in &#x60;can_move_messages_between_topics_group&#x60; were able move messages between topics of a channel.
func (r ApiUpdateStreamRequest) CanMoveMessagesWithinChannelGroup(canMoveMessagesWithinChannelGroup models.GroupSettingValueUpdate) ApiUpdateStreamRequest {
	r.canMoveMessagesWithinChannelGroup = &canMoveMessagesWithinChannelGroup
	return r
}

// The set of users who have permission to post in this channel expressed as an [update to a group-setting value][update-group-setting].  [update-group-setting]: /api/group-setting-values#updating-group-setting-values  Note that a user must have metadata access to a channel and permission to administer the channel in order to modify this setting.  **Changes**: New in Zulip 10.0 (feature level 333). Previously &#x60;stream_post_policy&#x60; field used to control the permission to post in the channel.
func (r ApiUpdateStreamRequest) CanSendMessageGroup(canSendMessageGroup models.GroupSettingValueUpdate) ApiUpdateStreamRequest {
	r.canSendMessageGroup = &canSendMessageGroup
	return r
}

// The set of users who have permission to subscribe themselves to this channel expressed as an [update to a group-setting value][update-group-setting].  [update-group-setting]: /api/group-setting-values#updating-group-setting-values  Everyone, excluding guests, can subscribe to any public channel irrespective of this setting.  Users in this group can subscribe to a private channel as well.  Note that a user must [have content access](zulip.com/help/channel-permissions to a channel and permission to administer the channel in order to modify this setting.  **Changes**: New in Zulip 10.0 (feature level 357).
func (r ApiUpdateStreamRequest) CanSubscribeGroup(canSubscribeGroup models.GroupSettingValueUpdate) ApiUpdateStreamRequest {
	r.canSubscribeGroup = &canSubscribeGroup
	return r
}

// The set of users who have permission to to resolve topics in this channel expressed as an [update to a group-setting value][update-group-setting].  [update-group-setting]: /api/group-setting-values#updating-group-setting-values  Users who have similar realm-level permissions can resolve topics in a channel regardless of the value of this setting.  **Changes**: New in Zulip 11.0 (feature level 402).
func (r ApiUpdateStreamRequest) CanResolveTopicsGroup(canResolveTopicsGroup models.GroupSettingValueUpdate) ApiUpdateStreamRequest {
	r.canResolveTopicsGroup = &canResolveTopicsGroup
	return r
}

func (r ApiUpdateStreamRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.UpdateStreamExecute(r)
}

/*
UpdateStream Update a channel

Configure the channel with the ID `stream_id`. This endpoint supports
an organization administrator editing any property of a channel,
including:

  - Channel [name](zulip.com/help/rename-a-channel and [description](zulip.com/help/change-the-channel-description
  - Channel [permissions](zulip.com/help/channel-permissions, including
    [privacy](zulip.com/help/change-the-privacy-of-a-channel and [who can
    send](zulip.com/help/channel-posting-policy.

Note that an organization administrator's ability to change a
[private channel's permissions](zulip.com/help/channel-permissions#private-channels
depends on them being subscribed to the channel.

**Changes**: Before Zulip 10.0 (feature level 362), channel privacy could not be
edited for archived channels.

Removed `stream_post_policy` and `is_announcement_only`
parameters in Zulip 10.0 (feature level 333), as permission to post
in the channel is now controlled by `can_send_message_group`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param streamId The ID of the channel to access.
	@return ApiUpdateStreamRequest
*/
func (c *ZulipClient) UpdateStream(ctx context.Context, streamId int32) ApiUpdateStreamRequest {
	return ApiUpdateStreamRequest{
		ApiService: c,
		ctx:        ctx,
		streamId:   streamId,
	}
}

// Execute executes the request
//
//	@return models.JsonSuccess
func (c *ZulipClient) UpdateStreamExecute(r ApiUpdateStreamRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.JsonSuccess
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams/{stream_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", url.PathEscape(parameterValueToString(r.streamId, "streamId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	if r.newName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "new_name", r.newName, "", "")
	}
	if r.isPrivate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_private", r.isPrivate, "form", "")
	}
	if r.isWebPublic != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_web_public", r.isWebPublic, "form", "")
	}
	if r.historyPublicToSubscribers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "history_public_to_subscribers", r.historyPublicToSubscribers, "form", "")
	}
	if r.isDefaultStream != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_default_stream", r.isDefaultStream, "form", "")
	}
	if r.messageRetentionDays != nil {
		paramJson, err := parameterToJson(*r.messageRetentionDays)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("message_retention_days", paramJson)
	}
	if r.isArchived != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_archived", r.isArchived, "", "")
	}
	if r.folderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "folder_id", r.folderId, "form", "")
	}
	if r.topicsPolicy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "topics_policy", r.topicsPolicy, "", "")
	}
	if r.canAddSubscribersGroup != nil {
		paramJson, err := parameterToJson(*r.canAddSubscribersGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_add_subscribers_group", paramJson)
	}
	if r.canRemoveSubscribersGroup != nil {
		paramJson, err := parameterToJson(*r.canRemoveSubscribersGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_remove_subscribers_group", paramJson)
	}
	if r.canAdministerChannelGroup != nil {
		paramJson, err := parameterToJson(*r.canAdministerChannelGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_administer_channel_group", paramJson)
	}
	if r.canDeleteAnyMessageGroup != nil {
		paramJson, err := parameterToJson(*r.canDeleteAnyMessageGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_delete_any_message_group", paramJson)
	}
	if r.canDeleteOwnMessageGroup != nil {
		paramJson, err := parameterToJson(*r.canDeleteOwnMessageGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_delete_own_message_group", paramJson)
	}
	if r.canMoveMessagesOutOfChannelGroup != nil {
		paramJson, err := parameterToJson(*r.canMoveMessagesOutOfChannelGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_move_messages_out_of_channel_group", paramJson)
	}
	if r.canMoveMessagesWithinChannelGroup != nil {
		paramJson, err := parameterToJson(*r.canMoveMessagesWithinChannelGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_move_messages_within_channel_group", paramJson)
	}
	if r.canSendMessageGroup != nil {
		paramJson, err := parameterToJson(*r.canSendMessageGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_send_message_group", paramJson)
	}
	if r.canSubscribeGroup != nil {
		paramJson, err := parameterToJson(*r.canSubscribeGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_subscribe_group", paramJson)
	}
	if r.canResolveTopicsGroup != nil {
		paramJson, err := parameterToJson(*r.canResolveTopicsGroup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("can_resolve_topics_group", paramJson)
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v models.UpdateStream400Response
			err = c.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubscriptionSettingsRequest struct {
	ctx              context.Context
	ApiService       ChannelsAPI
	subscriptionData *[]models.UpdateSubscriptionSetting
}

// A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the channel, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.
func (r ApiUpdateSubscriptionSettingsRequest) SubscriptionData(subscriptionData []models.UpdateSubscriptionSetting) ApiUpdateSubscriptionSettingsRequest {
	r.subscriptionData = &subscriptionData
	return r
}

func (r ApiUpdateSubscriptionSettingsRequest) Execute() (*models.IgnoredParametersSuccess, *http.Response, error) {
	return r.ApiService.UpdateSubscriptionSettingsExecute(r)
}

/*
UpdateSubscriptionSettings Update subscription settings

This endpoint is used to update the user's personal settings for the
channels they are subscribed to, including muting, color, pinning, and
per-channel notification settings.

**Changes**: Prior to Zulip 5.0 (feature level 111), response
object included the `subscription_data` in the
request. The endpoint now returns the more ergonomic
[`ignored_parameters_unsupported`][ignored-parameters] array instead.

[ignored-parameters]: /api/rest-error-handling#ignored-parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateSubscriptionSettingsRequest
*/
func (c *ZulipClient) UpdateSubscriptionSettings(ctx context.Context) ApiUpdateSubscriptionSettingsRequest {
	return ApiUpdateSubscriptionSettingsRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.IgnoredParametersSuccess
func (c *ZulipClient) UpdateSubscriptionSettingsExecute(r ApiUpdateSubscriptionSettingsRequest) (*models.IgnoredParametersSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.IgnoredParametersSuccess
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions/properties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionData == nil {
		return localVarReturnValue, nil, reportError("subscriptionData is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subscription_data", r.subscriptionData, "form", "multi")
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubscriptionsRequest struct {
	ctx        context.Context
	ApiService ChannelsAPI
	delete     *[]string
	add        *[]models.UpdateSubscriptionsRequestAddInner
}

// A list of channel names to unsubscribe from.
func (r ApiUpdateSubscriptionsRequest) Delete(delete []string) ApiUpdateSubscriptionsRequest {
	r.delete = &delete
	return r
}

// A list of objects describing which channels to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the channel is to be created, its description.
func (r ApiUpdateSubscriptionsRequest) Add(add []models.UpdateSubscriptionsRequestAddInner) ApiUpdateSubscriptionsRequest {
	r.add = &add
	return r
}

func (r ApiUpdateSubscriptionsRequest) Execute() (*models.UpdateSubscriptions200Response, *http.Response, error) {
	return r.ApiService.UpdateSubscriptionsExecute(r)
}

/*
UpdateSubscriptions Update subscriptions

Update which channels you are subscribed to.

**Changes**: Before Zulip 10.0 (feature level 362),
subscriptions in archived channels could not be modified.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateSubscriptionsRequest
*/
func (c *ZulipClient) UpdateSubscriptions(ctx context.Context) ApiUpdateSubscriptionsRequest {
	return ApiUpdateSubscriptionsRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.UpdateSubscriptions200Response
func (c *ZulipClient) UpdateSubscriptionsExecute(r ApiUpdateSubscriptionsRequest) (*models.UpdateSubscriptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.UpdateSubscriptions200Response
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.delete != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "delete", r.delete, "form", "multi")
	}
	if r.add != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "add", r.add, "form", "multi")
	}
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserTopicRequest struct {
	ctx              context.Context
	ApiService       ChannelsAPI
	streamId         *int32
	topic            *string
	visibilityPolicy *int32
}

// The ID of the channel to access.
func (r ApiUpdateUserTopicRequest) StreamId(streamId int32) ApiUpdateUserTopicRequest {
	r.streamId = &streamId
	return r
}

// The topic for which the personal preferences needs to be updated. Note that the request will succeed regardless of whether any messages have been sent to the specified topic.  Clients should use the &#x60;max_topic_length&#x60; returned by the [&#x60;POST /register&#x60;](zulip.com/api/register-queue endpoint to determine the maximum topic length.  Note: When the value of &#x60;realm_empty_topic_display_name&#x60; found in the [POST /register](zulip.com/api/register-queue response is used for this parameter, it is interpreted as an empty string.  **Changes**: Before Zulip 10.0 (feature level 334), empty string was not a valid topic name for channel messages.
func (r ApiUpdateUserTopicRequest) Topic(topic string) ApiUpdateUserTopicRequest {
	r.topic = &topic
	return r
}

// Controls which visibility policy to set.  - 0 &#x3D; None. Removes the visibility policy previously set for the topic. - 1 &#x3D; Muted. [Mutes the topic](zulip.com/help/mute-a-topic in a channel. - 2 &#x3D; Unmuted. [Unmutes the topic](zulip.com/help/mute-a-topic in a muted channel. - 3 &#x3D; Followed. [Follows the topic](zulip.com/help/follow-a-topic.  In an unmuted channel, a topic visibility policy of unmuted will have the same effect as the \\\&quot;None\\\&quot; visibility policy.  **Changes**: In Zulip 7.0 (feature level 219), added followed as a visibility policy option.
func (r ApiUpdateUserTopicRequest) VisibilityPolicy(visibilityPolicy int32) ApiUpdateUserTopicRequest {
	r.visibilityPolicy = &visibilityPolicy
	return r
}

func (r ApiUpdateUserTopicRequest) Execute() (*models.JsonSuccess, *http.Response, error) {
	return r.ApiService.UpdateUserTopicExecute(r)
}

/*
UpdateUserTopic Update personal preferences for a topic

This endpoint is used to update the personal preferences for a topic,
such as the topic's visibility policy, which is used to implement
[mute a topic](zulip.com/help/mute-a-topic and related features.

This endpoint can be used to update the visibility policy for the single
channel and topic pair indicated by the parameters for a user.

**Changes**: New in Zulip 7.0 (feature level 170). Previously,
toggling whether a topic was muted or unmuted was managed by the
[PATCH /users/me/subscriptions/muted_topics](zulip.com/api/mute-topic endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateUserTopicRequest
*/
func (c *ZulipClient) UpdateUserTopic(ctx context.Context) ApiUpdateUserTopicRequest {
	return ApiUpdateUserTopicRequest{
		ApiService: c,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return models.JsonSuccess
func (c *ZulipClient) UpdateUserTopicExecute(r ApiUpdateUserTopicRequest) (*models.JsonSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *models.JsonSuccess
	)

	localBasePath, err := c.ServerURL()
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_topics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.streamId == nil {
		return localVarReturnValue, nil, reportError("streamId is required and must be specified")
	}
	if r.topic == nil {
		return localVarReturnValue, nil, reportError("topic is required and must be specified")
	}
	if r.visibilityPolicy == nil {
		return localVarReturnValue, nil, reportError("visibilityPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "stream_id", r.streamId, "form", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "topic", r.topic, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "visibility_policy", r.visibilityPolicy, "form", "")
	req, err := c.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := c.callAPI(r.ctx, req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = c.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
