/*
Zulip REST API

Testing MessagesAPIService

*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech);

package api_test

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/tum-zulip/go-zulip/pkg/api"
)

func Test_MessagesAPIService(t *testing.T) {
	runForClients(t, allClients, func(t *testing.T, apiClient *api.ZulipClient) {
		ctx := context.Background()

		t.Run("AddReaction", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			resp, httpRes, err := apiClient.AddReaction(ctx, msg.messageId).
				EmojiName("smile").
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("CheckMessagesMatchNarrow", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			narrow := []map[string]interface{}{
				{"operator": "stream", "operand": msg.streamName},
				{"operator": "topic", "operand": msg.topic},
			}

			resp, httpRes, err := apiClient.CheckMessagesMatchNarrow(ctx).
				MsgIds([]int64{msg.messageId}).
				Narrow(narrow).
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)

			key := strconv.Itoa(int(msg.messageId))
			if resp.Messages != nil {
				assert.Contains(t, resp.Messages, key)
			}
		})

		t.Run("DeleteMessage", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			resp, httpRes, err := apiClient.DeleteMessage(ctx, msg.messageId).Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("GetFileTemporaryUrl", func(t *testing.T) {
			upload := uploadFileForTest(t, ctx, apiClient)

			realmId, filename := parseUploadedFilePath(t, upload.Url)

			resp, httpRes, err := apiClient.GetFileTemporaryUrl(ctx, realmId, filename).Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.NotEmpty(t, resp.Url)
		})

		t.Run("GetMessage", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			resp, httpRes, err := apiClient.GetMessage(ctx, msg.messageId).Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.Equal(t, msg.messageId, resp.Message.Id)
		})

		t.Run("GetMessageHistory", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			updateContent := fmt.Sprintf("updated %s", uniqueName("message"))
			_, _, err := apiClient.UpdateMessage(ctx, msg.messageId).
				Content(updateContent).
				Execute()
			require.NoError(t, err)

			resp, httpRes, err := apiClient.GetMessageHistory(ctx, msg.messageId).Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.NotEmpty(t, resp.MessageHistory)
		})

		t.Run("GetMessages", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			narrow := []map[string]interface{}{
				{"operator": "stream", "operand": msg.streamName},
				{"operator": "topic", "operand": msg.topic},
			}

			resp, httpRes, err := apiClient.GetMessages(ctx).
				Anchor(strconv.Itoa(int(msg.messageId))).
				IncludeAnchor(true).
				NumBefore(0).
				NumAfter(0).
				Narrow(narrow).
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.NotEmpty(t, resp.Messages)
		})

		t.Run("GetReadReceipts", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			resp, httpRes, err := apiClient.GetReadReceipts(ctx, msg.messageId).Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("MarkAllAsRead", func(t *testing.T) {
			resp, httpRes, err := apiClient.MarkAllAsRead(ctx).Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("MarkStreamAsRead", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			resp, httpRes, err := apiClient.MarkStreamAsRead(ctx).
				StreamId(msg.streamId).
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("MarkTopicAsRead", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			resp, httpRes, err := apiClient.MarkTopicAsRead(ctx).
				StreamId(msg.streamId).
				TopicName(msg.topic).
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("RemoveReaction", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			_, _, err := apiClient.AddReaction(ctx, msg.messageId).
				EmojiName("smile").
				Execute()
			require.NoError(t, err)

			resp, httpRes, err := apiClient.RemoveReaction(ctx, msg.messageId).
				EmojiName("smile").
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("RenderMessage", func(t *testing.T) {
			content := "**bold** _italic_"
			resp, httpRes, err := apiClient.RenderMessage(ctx).
				Content(content).
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.Contains(t, resp.Rendered, "<strong>bold</strong>")
		})

		t.Run("ReportMessage", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			resp, httpRes, err := apiClient.ReportMessage(ctx, msg.messageId).
				ReportType("spam").
				Description("reported by automated tests").
				Execute()

			if err != nil {
				var apiErr *api.GenericOpenAPIError
				if errors.As(err, &apiErr) {
					body := strings.TrimSpace(string(apiErr.Body()))
					lower := strings.ToLower(fmt.Sprintf("%s %s", apiErr.Error(), body))
					if strings.Contains(lower, "moderation") ||
						strings.Contains(lower, "not configured") ||
						strings.Contains(lower, "message reporting is not enabled") {
						t.Skipf("message reporting unavailable: %s", body)
					}
				}
			}

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("SendMessage", func(t *testing.T) {
			_, streamId := createRandomChannel(t, apiClient, getOwnUserId(t, apiClient))
			topic := uniqueName("topic")
			content := fmt.Sprintf("message sent via client %s", uniqueName("content"))

			resp, httpRes, err := apiClient.SendMessage(ctx).
				RecipientType(api.RecipientTypeChannel).
				To(api.ChannelAsReipient(streamId)).
				Topic(topic).
				Content(content).
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.Greater(t, resp.Id, int64(0))
		})

		t.Run("UpdateMessage", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)
			newContent := fmt.Sprintf("edited %s", uniqueName("content"))

			resp, httpRes, err := apiClient.UpdateMessage(ctx, msg.messageId).
				Content(newContent).
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
		})

		t.Run("UpdateMessageFlags", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			resp, httpRes, err := apiClient.UpdateMessageFlags(ctx).
				Messages([]int64{msg.messageId}).
				Op("add").
				Flag("starred").
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.Contains(t, resp.Messages, msg.messageId)
		})

		t.Run("UpdateMessageFlagsForNarrow", func(t *testing.T) {
			msg := createStreamMessage(t, apiClient)

			// streamOperand := UpdateFlagsNarrowOperandFromString(&msg.streamName)
			// topicOperand := UpdateFlagsNarrowOperandFromString(&msg.topic)
			// streamFilter := NewUpdateFlagsNarrowFilter("stream", streamOperand)
			// topicFilter := NewUpdateFlagsNarrowFilter("topic", topicOperand)
			// TODO
			narrow := []api.UpdateFlagsNarrowClause{}

			resp, httpRes, err := apiClient.UpdateMessageFlagsForNarrow(ctx).
				Anchor(strconv.Itoa(int(msg.messageId))).
				NumBefore(0).
				NumAfter(0).
				IncludeAnchor(true).
				Narrow(narrow).
				Op("add").
				Flag("starred").
				Execute()

			require.NoError(t, err)
			require.NotNil(t, resp)
			requireStatusOK(t, httpRes)
			assert.GreaterOrEqual(t, resp.ProcessedCount, int64(1))
		})

		t.Run("UploadFile", func(t *testing.T) {
			resp := uploadFileForTest(t, ctx, apiClient)
			assert.NotEmpty(t, resp.Url)
			assert.NotEmpty(t, resp.Filename)
		})
	})
}

type streamMessage struct {
	streamName string
	streamId   int64
	topic      string
	messageId  int64
}

func createStreamMessage(t *testing.T, apiClient *api.ZulipClient) streamMessage {
	t.Helper()

	userId := getOwnUserId(t, apiClient)
	streamName, streamId := createRandomChannel(t, apiClient, userId)
	topic := uniqueName("topic")
	content := fmt.Sprintf("automated test message %s", uniqueName("content"))
	messageId := sendStreamMessage(t, apiClient, streamId, topic, content)
	assert.Greater(t, messageId, int64(0))

	return streamMessage{
		streamName: streamName,
		streamId:   streamId,
		topic:      topic,
		messageId:  messageId,
	}
}

func uploadFileForTest(t *testing.T, ctx context.Context, apiClient *api.ZulipClient) *api.UploadFileResponse {
	t.Helper()

	tmp, err := os.CreateTemp("", "zulip-upload-*.txt")
	require.NoError(t, err)
	defer func() {
		tmp.Close()
		os.Remove(tmp.Name())
	}()

	_, err = tmp.WriteString("uploaded from automated test")
	require.NoError(t, err)
	_, err = tmp.Seek(0, 0)
	require.NoError(t, err)

	resp, httpRes, err := apiClient.UploadFile(ctx).
		Filename(tmp).
		Execute()

	require.NoError(t, err)
	require.NotNil(t, resp)
	requireStatusOK(t, httpRes)

	return resp
}

func parseUploadedFilePath(t *testing.T, uploadPath string) (int64, string) {
	t.Helper()

	require.NotEmpty(t, uploadPath)

	trimmed := strings.TrimLeft(uploadPath, "/")
	parts := strings.Split(trimmed, "/")
	require.GreaterOrEqual(t, len(parts), 3, "unexpected upload path: %s", uploadPath)
	require.Equal(t, "user_uploads", parts[0], "unexpected upload prefix: %s", uploadPath)

	realmId, err := strconv.ParseInt(parts[1], 10, 64)
	require.NoError(t, err)

	filename := strings.Join(parts[2:], "/")
	require.NotEmpty(t, filename)

	return realmId, filename
}

func createDirectMessage(t *testing.T, apiClient *api.ZulipClient, to int64) int64 {
	t.Helper()

	content := uniqueName("content")
	resp, httpRes, err := apiClient.SendMessage(context.Background()).
		RecipientType(api.RecipientTypePrivate).
		To(api.UserAsRecipient(to)).
		Content(content).
		Execute()

	require.NoError(t, err)
	require.NotNil(t, resp)
	requireStatusOK(t, httpRes)
	require.Greater(t, resp.Id, int64(0))

	return resp.Id
}
