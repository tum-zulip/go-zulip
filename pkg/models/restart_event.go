/*
Zulip REST API

Powerful open source group chat

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package models

import (
	"encoding/json"
)

// checks if the RestartEvent type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &RestartEvent{}

// RestartEvent Event sent to all the users whenever the Zulip server restarts.  Specifically, this event is sent whenever the Tornado process for the user is restarted; in particular, this will always happen when the Zulip server is upgraded.  Clients should use this event to update their tracking of the server's capabilities, and to decide if they wish to get a new event queue after a server upgrade. Clients doing so must implement a random delay strategy to spread such restarts over 5 minutes or more to avoid creating a synchronized thundering herd effect.  **Changes**: Removed the `immediate` flag, which was only used by web clients in development, in Zulip 9.0 (feature level 240).
type RestartEvent struct {
	// The ID of the event. Events appear in increasing order but may not be consecutive.
	Id   *int32  `json:"id,omitempty"`
	Type *string `json:"type,omitempty"`
	// The Zulip version number, in the format where this appears in the [server_settings](zulip.com/api/get-server-settings and [register](zulip.com/api/register-queue responses.  **Changes**: New in Zulip 4.0 (feature level 59).
	ZulipVersion *string `json:"zulip_version,omitempty"`
	// The Zulip merge base number, in the format where this appears in the [server_settings](zulip.com/api/get-server-settings and [register](zulip.com/api/register-queue responses.  **Changes**: New in Zulip 5.0 (feature level 88).
	ZulipMergeBase *string `json:"zulip_merge_base,omitempty"`
	// The [Zulip feature level](zulip.com/api/changelog of the server after the restart.  Clients should use this to update their tracking of the server's capabilities, and may choose to refetch their state and create a new event queue when the API feature level has changed in a way that the client finds significant. Clients choosing to do so must implement a random delay strategy to spread such restarts over 5 or more minutes to avoid creating a synchronized thundering herd effect.  **Changes**: New in Zulip 4.0 (feature level 59).
	ZulipFeatureLevel *int32 `json:"zulip_feature_level,omitempty"`
	// The timestamp at which the server started.
	ServerGeneration *Timestamp `json:"server_generation,omitempty"`
}

// NewSubscriptionRemoveEvent5 instantiates a new RestartEvent object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewSubscriptionRemoveEvent5() *RestartEvent {
	this := RestartEvent{}
	return &this
}

// NewSubscriptionRemoveEvent5WithDefaults instantiates a new RestartEvent object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewSubscriptionRemoveEvent5WithDefaults() *RestartEvent {
	this := RestartEvent{}
	return &this
}

// GetId returns the Id field value if set, zero value otherwise.
func (o *RestartEvent) GetId() int32 {
	if o == nil || IsNil(o.Id) {
		var ret int32
		return ret
	}
	return *o.Id
}

// GetIdOk returns a tuple with the Id field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *RestartEvent) GetIdOk() (*int32, bool) {
	if o == nil || IsNil(o.Id) {
		return nil, false
	}
	return o.Id, true
}

// HasId returns a boolean if a field has been set.
func (o *RestartEvent) HasId() bool {
	if o != nil && !IsNil(o.Id) {
		return true
	}

	return false
}

// SetId gets a reference to the given int32 and assigns it to the Id field.
func (o *RestartEvent) SetId(v int32) {
	o.Id = &v
}

// GetType returns the Type field value if set, zero value otherwise.
func (o *RestartEvent) GetType() string {
	if o == nil || IsNil(o.Type) {
		var ret string
		return ret
	}
	return *o.Type
}

// GetTypeOk returns a tuple with the Type field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *RestartEvent) GetTypeOk() (*string, bool) {
	if o == nil || IsNil(o.Type) {
		return nil, false
	}
	return o.Type, true
}

// HasType returns a boolean if a field has been set.
func (o *RestartEvent) HasType() bool {
	if o != nil && !IsNil(o.Type) {
		return true
	}

	return false
}

// SetType gets a reference to the given string and assigns it to the Type field.
func (o *RestartEvent) SetType(v string) {
	o.Type = &v
}

// GetZulipVersion returns the ZulipVersion field value if set, zero value otherwise.
func (o *RestartEvent) GetZulipVersion() string {
	if o == nil || IsNil(o.ZulipVersion) {
		var ret string
		return ret
	}
	return *o.ZulipVersion
}

// GetZulipVersionOk returns a tuple with the ZulipVersion field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *RestartEvent) GetZulipVersionOk() (*string, bool) {
	if o == nil || IsNil(o.ZulipVersion) {
		return nil, false
	}
	return o.ZulipVersion, true
}

// HasZulipVersion returns a boolean if a field has been set.
func (o *RestartEvent) HasZulipVersion() bool {
	if o != nil && !IsNil(o.ZulipVersion) {
		return true
	}

	return false
}

// SetZulipVersion gets a reference to the given string and assigns it to the ZulipVersion field.
func (o *RestartEvent) SetZulipVersion(v string) {
	o.ZulipVersion = &v
}

// GetZulipMergeBase returns the ZulipMergeBase field value if set, zero value otherwise.
func (o *RestartEvent) GetZulipMergeBase() string {
	if o == nil || IsNil(o.ZulipMergeBase) {
		var ret string
		return ret
	}
	return *o.ZulipMergeBase
}

// GetZulipMergeBaseOk returns a tuple with the ZulipMergeBase field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *RestartEvent) GetZulipMergeBaseOk() (*string, bool) {
	if o == nil || IsNil(o.ZulipMergeBase) {
		return nil, false
	}
	return o.ZulipMergeBase, true
}

// HasZulipMergeBase returns a boolean if a field has been set.
func (o *RestartEvent) HasZulipMergeBase() bool {
	if o != nil && !IsNil(o.ZulipMergeBase) {
		return true
	}

	return false
}

// SetZulipMergeBase gets a reference to the given string and assigns it to the ZulipMergeBase field.
func (o *RestartEvent) SetZulipMergeBase(v string) {
	o.ZulipMergeBase = &v
}

// GetZulipFeatureLevel returns the ZulipFeatureLevel field value if set, zero value otherwise.
func (o *RestartEvent) GetZulipFeatureLevel() int32 {
	if o == nil || IsNil(o.ZulipFeatureLevel) {
		var ret int32
		return ret
	}
	return *o.ZulipFeatureLevel
}

// GetZulipFeatureLevelOk returns a tuple with the ZulipFeatureLevel field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *RestartEvent) GetZulipFeatureLevelOk() (*int32, bool) {
	if o == nil || IsNil(o.ZulipFeatureLevel) {
		return nil, false
	}
	return o.ZulipFeatureLevel, true
}

// HasZulipFeatureLevel returns a boolean if a field has been set.
func (o *RestartEvent) HasZulipFeatureLevel() bool {
	if o != nil && !IsNil(o.ZulipFeatureLevel) {
		return true
	}

	return false
}

// SetZulipFeatureLevel gets a reference to the given int32 and assigns it to the ZulipFeatureLevel field.
func (o *RestartEvent) SetZulipFeatureLevel(v int32) {
	o.ZulipFeatureLevel = &v
}

// GetServerGeneration returns the ServerGeneration field value if set, zero value otherwise.
func (o *RestartEvent) GetServerGeneration() Timestamp {
	if o == nil || IsNil(o.ServerGeneration) {
		var ret Timestamp
		return ret
	}
	return *o.ServerGeneration
}

// GetServerGenerationOk returns a tuple with the ServerGeneration field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *RestartEvent) GetServerGenerationOk() (*Timestamp, bool) {
	if o == nil || IsNil(o.ServerGeneration) {
		return nil, false
	}
	return o.ServerGeneration, true
}

// HasServerGeneration returns a boolean if a field has been set.
func (o *RestartEvent) HasServerGeneration() bool {
	if o != nil && !IsNil(o.ServerGeneration) {
		return true
	}

	return false
}

// SetServerGeneration gets a reference to the given Timestamp and assigns it to the ServerGeneration field.
func (o *RestartEvent) SetServerGeneration(v Timestamp) {
	o.ServerGeneration = &v
}

func (o RestartEvent) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o RestartEvent) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.Id) {
		toSerialize["id"] = o.Id
	}
	if !IsNil(o.Type) {
		toSerialize["type"] = o.Type
	}
	if !IsNil(o.ZulipVersion) {
		toSerialize["zulip_version"] = o.ZulipVersion
	}
	if !IsNil(o.ZulipMergeBase) {
		toSerialize["zulip_merge_base"] = o.ZulipMergeBase
	}
	if !IsNil(o.ZulipFeatureLevel) {
		toSerialize["zulip_feature_level"] = o.ZulipFeatureLevel
	}
	if !IsNil(o.ServerGeneration) {
		toSerialize["server_generation"] = o.ServerGeneration
	}
	return toSerialize, nil
}

type NullableSubscriptionRemoveEvent5 struct {
	value *RestartEvent
	isSet bool
}

func (v NullableSubscriptionRemoveEvent5) Get() *RestartEvent {
	return v.value
}

func (v *NullableSubscriptionRemoveEvent5) Set(val *RestartEvent) {
	v.value = val
	v.isSet = true
}

func (v NullableSubscriptionRemoveEvent5) IsSet() bool {
	return v.isSet
}

func (v *NullableSubscriptionRemoveEvent5) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableSubscriptionRemoveEvent5(val *RestartEvent) *NullableSubscriptionRemoveEvent5 {
	return &NullableSubscriptionRemoveEvent5{value: val, isSet: true}
}

func (v NullableSubscriptionRemoveEvent5) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableSubscriptionRemoveEvent5) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
