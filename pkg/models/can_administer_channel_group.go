/*
Zulip REST API

Powerful open source group chat

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package models

import (
	"encoding/json"
)

// checks if the CanAdministerChannelGroup type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &CanAdministerChannelGroup{}

// CanAdministerChannelGroup A [group-setting value][setting-values] defining the set of users who have permission to administer this channel.  Organization administrators can administer every channel as though they were in this group without being explicitly listed here.  Note that a user must have metadata access to a channel and permission to administer the channel in order to modify this setting.  **Changes**: Prior to Zulip 10.0 (feature level 349) a user needed to [have content access](/help/channel-permissions) to a channel in order to modify it. The exception to this rule was that organization administrators can edit channel names and descriptions without having full access to the channel.  New in Zulip 10.0 (feature level 325). Prior to this change, the permission to administer channels was limited to realm administrators.  [setting-values]: /api/group-setting-values
type CanAdministerChannelGroup struct {
	// The list of IDs of individual users in the collection of users with this permission.  **Changes**: Prior to Zulip 10.0 (feature level 303), this list would include deactivated users who had the permission before being deactivated.
	DirectMembers []int32 `json:"direct_members,omitempty"`
	// The list of IDs of the groups in the collection of users with this permission.
	DirectSubgroups []int32 `json:"direct_subgroups,omitempty"`
}

// NewCanAdministerChannelGroup instantiates a new CanAdministerChannelGroup object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewCanAdministerChannelGroup() *CanAdministerChannelGroup {
	this := CanAdministerChannelGroup{}
	return &this
}

// NewCanAdministerChannelGroupWithDefaults instantiates a new CanAdministerChannelGroup object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewCanAdministerChannelGroupWithDefaults() *CanAdministerChannelGroup {
	this := CanAdministerChannelGroup{}
	return &this
}

// GetDirectMembers returns the DirectMembers field value if set, zero value otherwise.
func (o *CanAdministerChannelGroup) GetDirectMembers() []int32 {
	if o == nil || IsNil(o.DirectMembers) {
		var ret []int32
		return ret
	}
	return o.DirectMembers
}

// GetDirectMembersOk returns a tuple with the DirectMembers field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *CanAdministerChannelGroup) GetDirectMembersOk() ([]int32, bool) {
	if o == nil || IsNil(o.DirectMembers) {
		return nil, false
	}
	return o.DirectMembers, true
}

// HasDirectMembers returns a boolean if a field has been set.
func (o *CanAdministerChannelGroup) HasDirectMembers() bool {
	if o != nil && !IsNil(o.DirectMembers) {
		return true
	}

	return false
}

// SetDirectMembers gets a reference to the given []int32 and assigns it to the DirectMembers field.
func (o *CanAdministerChannelGroup) SetDirectMembers(v []int32) {
	o.DirectMembers = v
}

// GetDirectSubgroups returns the DirectSubgroups field value if set, zero value otherwise.
func (o *CanAdministerChannelGroup) GetDirectSubgroups() []int32 {
	if o == nil || IsNil(o.DirectSubgroups) {
		var ret []int32
		return ret
	}
	return o.DirectSubgroups
}

// GetDirectSubgroupsOk returns a tuple with the DirectSubgroups field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *CanAdministerChannelGroup) GetDirectSubgroupsOk() ([]int32, bool) {
	if o == nil || IsNil(o.DirectSubgroups) {
		return nil, false
	}
	return o.DirectSubgroups, true
}

// HasDirectSubgroups returns a boolean if a field has been set.
func (o *CanAdministerChannelGroup) HasDirectSubgroups() bool {
	if o != nil && !IsNil(o.DirectSubgroups) {
		return true
	}

	return false
}

// SetDirectSubgroups gets a reference to the given []int32 and assigns it to the DirectSubgroups field.
func (o *CanAdministerChannelGroup) SetDirectSubgroups(v []int32) {
	o.DirectSubgroups = v
}

func (o CanAdministerChannelGroup) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o CanAdministerChannelGroup) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.DirectMembers) {
		toSerialize["direct_members"] = o.DirectMembers
	}
	if !IsNil(o.DirectSubgroups) {
		toSerialize["direct_subgroups"] = o.DirectSubgroups
	}
	return toSerialize, nil
}

type NullableCanAdministerChannelGroup struct {
	value *CanAdministerChannelGroup
	isSet bool
}

func (v NullableCanAdministerChannelGroup) Get() *CanAdministerChannelGroup {
	return v.value
}

func (v *NullableCanAdministerChannelGroup) Set(val *CanAdministerChannelGroup) {
	v.value = val
	v.isSet = true
}

func (v NullableCanAdministerChannelGroup) IsSet() bool {
	return v.isSet
}

func (v *NullableCanAdministerChannelGroup) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCanAdministerChannelGroup(val *CanAdministerChannelGroup) *NullableCanAdministerChannelGroup {
	return &NullableCanAdministerChannelGroup{value: val, isSet: true}
}

func (v NullableCanAdministerChannelGroup) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCanAdministerChannelGroup) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
