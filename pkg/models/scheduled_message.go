/*
Zulip REST API

Powerful open source group chat

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package models

import (
	"bytes"
	"encoding/json"
	"fmt"
)

// checks if the ScheduledMessage type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &ScheduledMessage{}

// ScheduledMessage struct for ScheduledMessage
type ScheduledMessage struct {
	// The unique ID of the scheduled message, which can be used to modify or delete the scheduled message.  This is different from the unique ID that the message will have after it is sent.
	ScheduledMessageId int32 `json:"scheduled_message_id"`
	// The type of the scheduled message. Either `\"stream\"` or `\"private\"`.
	Type string                 `json:"type"`
	To   ScheduledMessageBaseTo `json:"to"`
	// Only present if `type` is `\"stream\"`.  The topic for the channel message.
	Topic *string `json:"topic,omitempty"`
	// The content/body of the scheduled message, in [Zulip-flavored Markdown](/help/format-your-message-using-markdown) format.  See [Markdown message formatting](/api/message-formatting) for details on Zulip's HTML format.
	Content string `json:"content"`
	// The content/body of the scheduled message rendered in HTML.
	RenderedContent string `json:"rendered_content"`
	// The UNIX timestamp for when the message will be sent by the server, in UTC seconds.
	ScheduledDeliveryTimestamp int32 `json:"scheduled_delivery_timestamp"`
	// Whether the server has tried to send the scheduled message and it failed to successfully send.  Clients that support unscheduling and editing scheduled messages should display scheduled messages with `\"failed\": true` with an indicator that the server failed to send the message at the scheduled time, so that the user is aware of the failure and can get the content of the scheduled message.  **Changes**: New in Zulip 7.0 (feature level 181).
	Failed bool `json:"failed"`
}

type _ScheduledMessage ScheduledMessage

// NewScheduledMessage instantiates a new ScheduledMessage object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewScheduledMessage(scheduledMessageId int32, type_ string, to ScheduledMessageBaseTo, content string, renderedContent string, scheduledDeliveryTimestamp int32, failed bool) *ScheduledMessage {
	this := ScheduledMessage{}
	this.ScheduledMessageId = scheduledMessageId
	this.Type = type_
	this.To = to
	this.Content = content
	this.RenderedContent = renderedContent
	this.ScheduledDeliveryTimestamp = scheduledDeliveryTimestamp
	this.Failed = failed
	return &this
}

// NewScheduledMessageWithDefaults instantiates a new ScheduledMessage object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewScheduledMessageWithDefaults() *ScheduledMessage {
	this := ScheduledMessage{}
	return &this
}

// GetScheduledMessageId returns the ScheduledMessageId field value
func (o *ScheduledMessage) GetScheduledMessageId() int32 {
	if o == nil {
		var ret int32
		return ret
	}

	return o.ScheduledMessageId
}

// GetScheduledMessageIdOk returns a tuple with the ScheduledMessageId field value
// and a boolean to check if the value has been set.
func (o *ScheduledMessage) GetScheduledMessageIdOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ScheduledMessageId, true
}

// SetScheduledMessageId sets field value
func (o *ScheduledMessage) SetScheduledMessageId(v int32) {
	o.ScheduledMessageId = v
}

// GetType returns the Type field value
func (o *ScheduledMessage) GetType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Type
}

// GetTypeOk returns a tuple with the Type field value
// and a boolean to check if the value has been set.
func (o *ScheduledMessage) GetTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Type, true
}

// SetType sets field value
func (o *ScheduledMessage) SetType(v string) {
	o.Type = v
}

// GetTo returns the To field value
func (o *ScheduledMessage) GetTo() ScheduledMessageBaseTo {
	if o == nil {
		var ret ScheduledMessageBaseTo
		return ret
	}

	return o.To
}

// GetToOk returns a tuple with the To field value
// and a boolean to check if the value has been set.
func (o *ScheduledMessage) GetToOk() (*ScheduledMessageBaseTo, bool) {
	if o == nil {
		return nil, false
	}
	return &o.To, true
}

// SetTo sets field value
func (o *ScheduledMessage) SetTo(v ScheduledMessageBaseTo) {
	o.To = v
}

// GetTopic returns the Topic field value if set, zero value otherwise.
func (o *ScheduledMessage) GetTopic() string {
	if o == nil || IsNil(o.Topic) {
		var ret string
		return ret
	}
	return *o.Topic
}

// GetTopicOk returns a tuple with the Topic field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ScheduledMessage) GetTopicOk() (*string, bool) {
	if o == nil || IsNil(o.Topic) {
		return nil, false
	}
	return o.Topic, true
}

// HasTopic returns a boolean if a field has been set.
func (o *ScheduledMessage) HasTopic() bool {
	if o != nil && !IsNil(o.Topic) {
		return true
	}

	return false
}

// SetTopic gets a reference to the given string and assigns it to the Topic field.
func (o *ScheduledMessage) SetTopic(v string) {
	o.Topic = &v
}

// GetContent returns the Content field value
func (o *ScheduledMessage) GetContent() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Content
}

// GetContentOk returns a tuple with the Content field value
// and a boolean to check if the value has been set.
func (o *ScheduledMessage) GetContentOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Content, true
}

// SetContent sets field value
func (o *ScheduledMessage) SetContent(v string) {
	o.Content = v
}

// GetRenderedContent returns the RenderedContent field value
func (o *ScheduledMessage) GetRenderedContent() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.RenderedContent
}

// GetRenderedContentOk returns a tuple with the RenderedContent field value
// and a boolean to check if the value has been set.
func (o *ScheduledMessage) GetRenderedContentOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.RenderedContent, true
}

// SetRenderedContent sets field value
func (o *ScheduledMessage) SetRenderedContent(v string) {
	o.RenderedContent = v
}

// GetScheduledDeliveryTimestamp returns the ScheduledDeliveryTimestamp field value
func (o *ScheduledMessage) GetScheduledDeliveryTimestamp() int32 {
	if o == nil {
		var ret int32
		return ret
	}

	return o.ScheduledDeliveryTimestamp
}

// GetScheduledDeliveryTimestampOk returns a tuple with the ScheduledDeliveryTimestamp field value
// and a boolean to check if the value has been set.
func (o *ScheduledMessage) GetScheduledDeliveryTimestampOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ScheduledDeliveryTimestamp, true
}

// SetScheduledDeliveryTimestamp sets field value
func (o *ScheduledMessage) SetScheduledDeliveryTimestamp(v int32) {
	o.ScheduledDeliveryTimestamp = v
}

// GetFailed returns the Failed field value
func (o *ScheduledMessage) GetFailed() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.Failed
}

// GetFailedOk returns a tuple with the Failed field value
// and a boolean to check if the value has been set.
func (o *ScheduledMessage) GetFailedOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Failed, true
}

// SetFailed sets field value
func (o *ScheduledMessage) SetFailed(v bool) {
	o.Failed = v
}

func (o ScheduledMessage) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o ScheduledMessage) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["scheduled_message_id"] = o.ScheduledMessageId
	toSerialize["type"] = o.Type
	toSerialize["to"] = o.To
	if !IsNil(o.Topic) {
		toSerialize["topic"] = o.Topic
	}
	toSerialize["content"] = o.Content
	toSerialize["rendered_content"] = o.RenderedContent
	toSerialize["scheduled_delivery_timestamp"] = o.ScheduledDeliveryTimestamp
	toSerialize["failed"] = o.Failed
	return toSerialize, nil
}

func (o *ScheduledMessage) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"scheduled_message_id",
		"type",
		"to",
		"content",
		"rendered_content",
		"scheduled_delivery_timestamp",
		"failed",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err
	}

	for _, requiredProperty := range requiredProperties {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varScheduledMessage := _ScheduledMessage{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varScheduledMessage)

	if err != nil {
		return err
	}

	*o = ScheduledMessage(varScheduledMessage)

	return err
}

type NullableScheduledMessage struct {
	value *ScheduledMessage
	isSet bool
}

func (v NullableScheduledMessage) Get() *ScheduledMessage {
	return v.value
}

func (v *NullableScheduledMessage) Set(val *ScheduledMessage) {
	v.value = val
	v.isSet = true
}

func (v NullableScheduledMessage) IsSet() bool {
	return v.isSet
}

func (v *NullableScheduledMessage) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableScheduledMessage(val *ScheduledMessage) *NullableScheduledMessage {
	return &NullableScheduledMessage{value: val, isSet: true}
}

func (v NullableScheduledMessage) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableScheduledMessage) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
